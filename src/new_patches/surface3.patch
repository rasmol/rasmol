*** applemac.c	2004/05/07 19:46:16	1.1
--- applemac.c	2005/01/16 20:25:17
***************
*** 517,522 ****
--- 520,526 ----
                SetMenuItemText(hand,6,tostr255(buffer,MsgStrs[StrMRibbons]));
                SetMenuItemText(hand,7,tostr255(buffer,MsgStrs[StrMStrands]));
                SetMenuItemText(hand,8,tostr255(buffer,MsgStrs[StrMCartoon]));
+               SetMenuItemText(hand,9,tostr255(buffer,MsgStrs[StrMMolSurf]));
                ReWriteStr255((*hand)->menuData,MsgStrs[StrMDisplay]);
                break;              
                              
*** cmndline.c	2004/05/07 19:46:16	1.1
--- cmndline.c	2005/01/16 20:25:17
***************
*** 638,655 ****
  
  
  static void PerformMouseFunc( int func, int delta, int max )
! {
      switch( func )
!     {   case(MM_ROTX):  WrapDial( DialRX, (Real)(2*delta)/max );
!                         ReDrawFlag |= RFRotateX;
                          break;
                          
          case(MM_ROTY):  if ( (RotMode == RotBond) && BondSelected) {
                            WrapDial( DialBRot, (Real)(2*delta)/max );
                          } else {
!                           WrapDial( DialRY, (Real)(2*delta)/max );
                          }
!                         ReDrawFlag |= RFRotateY;
                          break;
                          
          case(MM_ROTZ):  WrapDial( DialRZ, (Real)(2*delta)/max );
--- 638,695 ----
  
  
  static void PerformMouseFunc( int func, int delta, int max )
! {   Real xcomp, ycomp, zcomp;
!     int  dist;
!     
      switch( func )
!     {   case(MM_ROTX):  if ( (RotMode == RotBond) && BondSelected) {
!                           WrapDial( DialBRot, (Real)(2*delta)/max );
!                         } else {
!                           dist = PointX-XRange/2;
!                           if (dist < -XRange/8) {
!                             dist += XRange/8;
!                             dist *= 2;
!                             if (dist < -XRange/2) dist=-XRange/2;
!                           } else {
!                             dist -= XRange/8;
!                             if (dist < 0 ) dist = 0;
!                             dist *=2;
!                             if (dist > XRange/2) dist = XRange/2;
!                           }
!                           xcomp = (Real)(delta*(XRange/2-AbsFun(dist)))/((Real)(XRange/2));
!                           zcomp = (Real)(delta*dist)/((Real)(XRange/2));
!                           WrapDial( DialRX, 2*xcomp/(Real)max );
!                           WrapDial( DialRZ, 2*zcomp/(Real)max );
!                          /* WrapDial( DialRX, (Real)(2*delta)/max ); */
!                         }
!                         ReDrawFlag |= RFRotateX|RFRotateZ;
                          break;
  
         case(MM_ROTY):   if ( (RotMode == RotBond) && BondSelected) {
                            WrapDial( DialBRot, (Real)(2*delta)/max );
                          } else {
!                           dist = PointY-YRange/2;
!                           if (dist < -YRange/8) {
!                             dist += YRange/8;
!                             dist *= 2;
!                             if (dist < -YRange/2) dist=-YRange/2;
!                           } else {
!                             dist -= YRange/8;
!                             if (dist < 0 ) dist = 0;
!                             dist *=2;
!                             if (dist > YRange/2) dist = YRange/2;
!                           }
!                           ycomp = (Real)(delta*(YRange/2-AbsFun(dist)))/((Real)(YRange/2));
! #ifdef INVERT
!                           zcomp = (Real)(delta*dist)/((Real)(YRange/2));
! #else
!                           zcomp = (Real)(-delta*dist)/((Real)(YRange/2));
! #endif
!                           WrapDial( DialRY, 2*ycomp/(Real)max );
!                           WrapDial( DialRZ, 2*zcomp/(Real)max );
!                         /* WrapDial( DialRY, (Real)(2*delta)/max ); */
                          }
!                         ReDrawFlag |= RFRotateY|RFRotateZ;
                          break;
                          
          case(MM_ROTZ):  WrapDial( DialRZ, (Real)(2*delta)/max );
***************
*** 661,671 ****
                          break;
                          
          case(MM_TRNX):  ClampDial( DialTX, (Real)delta/max );
!                         ReDrawFlag |= RFTransX;
                          break;
  
          case(MM_TRNY):  ClampDial( DialTY, (Real)delta/max );
!                         ReDrawFlag |= RFTransY;
                          break;
  
          case(MM_CLIP):  ClampDial( DialSlab, (Real)delta/max );
--- 701,711 ----
                          break;
  
          case(MM_TRNX):  ClampDial( DialTX, (Real)delta/max );
!                         ReDrawFlag |= RFTransX|RFTransZ;
                          break;
  
          case(MM_TRNY):  ClampDial( DialTY, (Real)delta/max );
!                         ReDrawFlag |= RFTransY|RFTransZ;
                          break;
  
          case(MM_CLIP):  ClampDial( DialSlab, (Real)delta/max );
*** command.c	2004/05/07 19:46:16	1.1
--- command.c	2005/01/16 20:25:17
***************
*** 147,152 ****
--- 147,153 ----
                       for(group=chain->glist;group;group=group->gnext)    \
                       for(ptr=group->alist;ptr;ptr=ptr->anext)
  #define ForEachBond  for(bptr=Database->blist;bptr;bptr=bptr->bnext)
+ #define ForEachSurfBond  for(sbptr=Database->sblist;sbptr;sbptr=sbptr->sbnext)
  
  
  #define IsIdentChar(x)  ((isalnum(x))||((x)=='_')||((x)=='$'))
***************
*** 520,525 ****
--- 521,527 ----
              } else CreateMoleculeBonds(info,True,False);
          }
      }
+     if( CalcSurfFlag ) CreateSurfaceBonds();
  
      /* Explicit Hydrogen Bonds! */
      if( Info.hbondcount > 0 )
***************
*** 718,731 ****
  
  int DivertToData( int format, int info )
  {
-     register char *ptr;
      register int ch,len,done;
      register long pos;
      FILE *fp;
  
-     /* Avoid compiler warnings */
-     ptr = (char *)0;
- 
      fp = FileStack[FileDepth];
      pos = ftell(fp);
      do 
--- 720,729 ----
***************
*** 2178,2183 ****
--- 2176,2183 ----
                  } else ProbeRadius = (int)TokenValue;
  
              } else CommandError(MsgStrs[ErrNotNum]);
+             iProbeRad = (int)(Scale*(Real)ProbeRadius);
+             ReDrawFlag |= RFRefresh;
              break;
  
          case(SolventTok):
***************
*** 2189,2194 ****
--- 2189,2196 ----
              {   SolventDots = True;
                  ProbeRadius = 300;
              } else CommandError(MsgStrs[ErrBadOpt]);
+             iProbeRad = (int)(Scale*(Real)ProbeRadius);
+             ReDrawFlag |= RFRefresh;
              break;
  
          case(FontSizeTok):
***************
*** 2430,2435 ****
--- 2432,2439 ----
  					}
                  } else CommandError(MsgStrs[ErrBigNum]);
              } else CommandError(MsgStrs[ErrBadOpt]);
+             iProbeRad = (int)(Scale*(Real)ProbeRadius);
+             ReDrawFlag |= RFRefresh;
              break;
  
          default:
***************
*** 2970,2975 ****
--- 2974,2980 ----
  	register int neg, bloc=0;
  	register char ch;
  	register Bond __far *bptr;
+ 	register SurfBond __far *sbptr;
  	
  	if( !Database )
  		return;
***************
*** 3065,3075 ****
--- 3070,3088 ----
  				if( (bptr->srcatom->flag&bptr->dstatom->flag) & SelectFlag )
  				{   bptr->flag |= SelectFlag;
  				} else bptr->flag &= ~SelectFlag;
+ 			ForEachSurfBond
+ 				if( (sbptr->srcatom->flag&sbptr->dstatom->flag) & SelectFlag )
+ 				{   sbptr->flag |= SelectFlag;
+ 				} else sbptr->flag &= ~SelectFlag;
  		} else
  		{	ForEachBond
  		       if( (bptr->srcatom->flag|bptr->dstatom->flag) & SelectFlag )
  		       {   bptr->flag |= SelectFlag;
  		       } else bptr->flag &= ~SelectFlag;
+ 		    ForEachSurfBond
+ 		       if( (sbptr->srcatom->flag|sbptr->dstatom->flag) & SelectFlag )
+ 		       {   sbptr->flag |= SelectFlag;
+ 		       } else sbptr->flag &= ~SelectFlag;
  		}
  	}
  }
***************
*** 3510,3515 ****
--- 3523,3529 ----
                                if( TokenValue<=750 )
                                {   SetRadiusValue(MaxFun((int)TokenValue,1),
                                      SphereFlag);
+                                     DrawSurf = False;
                                    ReDrawFlag |= RFRefresh;
                                } else CommandError(MsgStrs[ErrBigNum]);
                            } else if( CurToken=='.' )
***************
*** 3517,3532 ****
--- 3531,3634 ----
                                if( TokenValue<=750 )
                                {   SetRadiusValue(MaxFun((int)TokenValue,1),
                                      SphereFlag);
+                                     DrawSurf = False;
                                    ReDrawFlag |= RFRefresh;
                                } else CommandError(MsgStrs[ErrBigNum]);
                            } else if( CurToken==UserTok )
                            {   UserMaskAttrib(MaskRadiusFlag);
+                               DrawSurf = False;
                                ReDrawFlag |= RFRefresh;
                            } else if( CurToken==TemperatureTok )
                            {   ReDrawFlag |= RFRefresh;
+                               DrawSurf = False;
                                SetRadiusTemperature( SphereFlag );
+                           } else if( CurToken==SolventTok )
+                           {   ReDrawFlag |= RFRefresh;
+                               SetVanWaalRadius( SphereFlag | ExpandFlag );
                            } else if( (CurToken==TrueTok) || !CurToken )
                            {   ReDrawFlag |= RFRefresh;
+                               DrawSurf = False;
+                               SetVanWaalRadius( SphereFlag );
+                           } else CommandError(MsgStrs[ErrBadArg]);
+                           break;
+         case(SurfaceTok):
+                           FetchToken();
+                           if( CurToken == SolventTok) {
+                             FetchToken();
+                             if( CurToken == DotsTok ) {
+                             } else if( CurToken == SolidTok ) {
+                             } else if( CurToken == NumberTok )
+                             {   if( *TokenPtr=='.' )
+                               {   TokenPtr++;
+                                   FetchFloat(TokenValue,250);   
+                               }
+                               if( TokenValue<=750 )
+                               {   ProbeRadius = (int)TokenValue;
+                                   DrawSurf = True;
+                                   ReDrawFlag |= RFRefresh;
+                                   SetVanWaalRadius( SphereFlag |  
+                                                     ExpandFlag );
+                               } else CommandError(MsgStrs[ErrBigNum]);
+                             } else CommandError(MsgStrs[ErrBadArg]);
+                               
+                           } else if( CurToken == MoleculeTok) {   
+                             FetchToken();
+                             if( CurToken == DotsTok ) {
+                             } else if( CurToken == SolidTok ) {
+                             } else if( CurToken == NumberTok )
+                             {   if( *TokenPtr=='.' )   
+                               {   TokenPtr++;
+                                   FetchFloat(TokenValue,250);
+                               }
+                             if( TokenValue<=750 )
+                               {   ProbeRadius = (int)TokenValue;
+                                   DrawSurf = True;
+                                   ReDrawFlag |= RFRefresh;
+                                   SetVanWaalRadius( SphereFlag | TouchFlag );
+                                   /* if( MainAtomCount+HetaAtomCount > 255 ) */
+                                       CreateSurfaceBonds();
+                               } else CommandError(MsgStrs[ErrBigNum]);
+                             } else CommandError(MsgStrs[ErrBadArg]);
+                           } else CommandError(MsgStrs[ErrBadArg]);
+                           break;
+ 
+         case(MolSurfTok):
+                           FetchToken();
+                           if( CurToken==FalseTok )
+                           {   DrawSurf = False;
+ 			      ReDrawFlag |= RFRefresh;
+                               DisableSpacefill();
+                           } else if( CurToken==NumberTok )
+                           {   if( *TokenPtr=='.' )
+                               {   TokenPtr++;
+                                   FetchFloat(TokenValue,250);
+                               }
+ 
+                               if( TokenValue<=750 )
+                               {   SetRadiusValue(MaxFun((int)TokenValue,1),
+                                     SphereFlag);
+                                     DrawSurf = True;
+                                   ReDrawFlag |= RFRefresh;
+                               } else CommandError(MsgStrs[ErrBigNum]);
+                           } else if( CurToken=='.' )
+                           {   FetchFloat(0,250);
+                               if( TokenValue<=750 )
+                               {   SetRadiusValue(MaxFun((int)TokenValue,1),
+                                     SphereFlag);
+ 			          DrawSurf = True;
+                                   ReDrawFlag |= RFRefresh;
+                               } else CommandError(MsgStrs[ErrBigNum]);
+                           } else if( CurToken==UserTok )
+                           {   UserMaskAttrib(MaskRadiusFlag);
+                               DrawSurf = True;
+                               ReDrawFlag |= RFRefresh;
+                           } else if( CurToken==TemperatureTok )
+                           {   DrawSurf = True;
+ 			      ReDrawFlag |= RFRefresh;
+                               SetRadiusTemperature( SphereFlag );
+                           } else if( (CurToken==TrueTok) || !CurToken )
+                           {   DrawSurf = True;
+                               ReDrawFlag |= RFRefresh;
                                SetVanWaalRadius( SphereFlag );
                            } else CommandError(MsgStrs[ErrBadArg]);
                            break;
*** command.h	2004/05/07 19:46:16	1.1
--- command.h	2005/01/16 20:25:16
***************
*** 134,139 ****
--- 137,143 ----
  int UseCIF=0;
  
  int CalcBondsFlag;
+ int CalcSurfFlag;
  int AllowWrite;
  
  int DefaultBackground = True;
***************
*** 148,153 ****
--- 152,158 ----
  extern int UseCIF;
  
  extern int CalcBondsFlag;
+ extern int CalcSurfFlag;
  extern int AllowWrite;
  
  extern int DefaultBackground;
*** graphics.h	2004/05/07 19:46:16	1.1
--- graphics.h	2005/01/16 20:25:16
***************
*** 157,162 ****
--- 157,163 ----
  HPALETTE ColourMap;
  HGLOBAL FBufHandle;
  HGLOBAL DBufHandle;
+ HGLOBAL CBufHandle;
  HBITMAP PixMap;
  HWND CanvWin;
  #endif /* MSWIN */
***************
*** 172,177 ****
--- 173,179 ----
  THPrint PrintHand;
  Handle FBufHandle;
  Handle DBufHandle;
+ Handle CBufHandle;
  #endif /* APPLEMAC */
  
  #ifdef X11WIN
***************
*** 218,223 ****
--- 220,226 ----
  extern HPALETTE ColourMap;
  extern HGLOBAL FBufHandle;
  extern HGLOBAL DBufHandle;
+ extern HGLOBAL CBufHandle;
  extern HBITMAP PixMap;
  extern HWND CanvWin;
  #endif /* MSWIN */
***************
*** 233,238 ****
--- 236,242 ----
  extern THPrint PrintHand;
  extern Handle FBufHandle;
  extern Handle DBufHandle;
+ extern Handle CBufHandle;
  #endif /* APPLEMAC */
  #endif
  
*** infile.c	2005/01/16 20:24:05	1.2
--- infile.c	2005/01/16 20:25:17
***************
*** 1058,1064 ****
      register int srcatm,dstatm;
      register Long dx, dy, dz;
      register Card dist2;
!     register Real scale;
      register char *cptr;
   
      DataFile = fp;
--- 1061,1067 ----
      register int srcatm,dstatm;
      register Long dx, dy, dz;
      register Card dist2;
!     register Real scale=0.0;
      register char *cptr;
   
      DataFile = fp;
***************
*** 2005,2018 ****
        ReadCIFDouble (cif, &ang_gamma, "_cell.angle_gamma", 
          "_cell_angle_gamma");
      if (result_a || result_b || result_c || 
!       result_alpha || result_beta || result_gamma)
        WriteString("Error: Missing or Incomplete CIF Cell\n\n");
      Info.cell[0] = length_a;
      Info.cell[1] = length_b;
      Info.cell[2] = length_c;
      Info.cell[3] = ang_alpha;
      Info.cell[4] = ang_beta;
      Info.cell[5] = ang_gamma;
      result_cell =
        cell2mat(Info.cell, Info.matf2o, Info.mato2f);
      if (!result_cell)
--- 2008,2030 ----
        ReadCIFDouble (cif, &ang_gamma, "_cell.angle_gamma", 
          "_cell_angle_gamma");
      if (result_a || result_b || result_c || 
!       result_alpha || result_beta || result_gamma) {
        WriteString("Error: Missing or Incomplete CIF Cell\n\n");
+       WriteString(" 1,1,1,90.,90.,90. assumed\n\n");
+       Info.cell[0] = 1.;
+       Info.cell[1] = 1.;
+       Info.cell[2] = 1.;
+       Info.cell[3] = 90.;
+       Info.cell[4] = 90.;
+       Info.cell[5] = 90.;
+     } else { 
      Info.cell[0] = length_a;
      Info.cell[1] = length_b;
      Info.cell[2] = length_c;
      Info.cell[3] = ang_alpha;
      Info.cell[4] = ang_beta;
      Info.cell[5] = ang_gamma;
+     }
      result_cell =
        cell2mat(Info.cell, Info.matf2o, Info.mato2f);
      if (!result_cell)
*** langsel.c	2004/05/07 19:46:16	1.1
--- langsel.c	2005/01/16 20:25:17
***************
*** 525,530 ****
--- 525,531 ----
    { "Ribbons",                                         StrMRibbons, English,0},
    { "Strands",                                         StrMStrands, English,3},
    { "Cartoons",                                        StrMCartoon, English,0},
+   { "Molecular Surface",                               StrMMolSurf, English,0},
  
    { "Alambre",                                         StrMWirefr,  Spanish,0},
    { "Esqueleto",                                       StrMBackbn,  Spanish,0},
***************
*** 534,539 ****
--- 535,541 ----
    { "Cintas",                                          StrMRibbons, Spanish,0},
    { "Hebras",                                          StrMStrands, Spanish,0},
    { "Dibujo",                                          StrMCartoon, Spanish,0},
+   { "Superficie Molecular",                            StrMMolSurf, Spanish,11},
  
    { "Fil",                                             StrMWirefr,  French,0},
    { "Squelette",                                       StrMBackbn,  French,0},
***************
*** 543,548 ****
--- 545,551 ----
    { "Rubans",                                          StrMRibbons, French,0},
    { "Tresses",                                         StrMStrands, French,0},
    { "Ebauches",                                        StrMCartoon, French,5},
+   { "Surface Molécular",                              StrMMolSurf, French,8},
  
    { "Fildiferro",                                      StrMWirefr,  Italian,0},
    { "Scheletro",                                       StrMBackbn,  Italian,0},
***************
*** 552,557 ****
--- 555,561 ----
    { "Nastri",                                          StrMRibbons, Italian,0},
    { "Fili",                                            StrMStrands, Italian,0},
    { "Vignetta",                                        StrMCartoon, Italian,0},
+   { "Superficie Molecolare",                           StrMMolSurf, Italian,11},
  
    { "Monochrome",                                      StrMMonochr, English,0},
    { "CPK",                                             StrMCPK,     English,0},
***************
*** 877,882 ****
--- 881,887 ----
    { "&Ribbons",                                        StrMRibbons, English,0},
    { "Str&ands",                                        StrMStrands, English,3},
    { "&Cartoons",                                       StrMCartoon, English,0},
+   { "&Molecular Surface",                              StrMMolSurf, English,0},
  
    { "&Alambre",                                        StrMWirefr,  Spanish,0},
    { "&Esqueleto",                                      StrMBackbn,  Spanish,0},
***************
*** 886,891 ****
--- 891,897 ----
    { "&Cintas",                                         StrMRibbons, Spanish,0},
    { "&Hebras",                                         StrMStrands, Spanish,0},
    { "&Dibujo",                                         StrMCartoon, Spanish,0},
+   { "Superficie &Molecular",                           StrMMolSurf, Spanish,11},
  
    { "&Fil",                                            StrMWirefr,  French,0},
    { "&Squelette",                                      StrMBackbn,  French,0},
***************
*** 895,900 ****
--- 901,907 ----
    { "&Ribbons",                                        StrMRibbons, French,0},
    { "&Tresses",                                        StrMStrands, French,0},
    { "Ebauc&hes",                                       StrMCartoon, French,5},
+   { "Surface &Molécular",                              StrMMolSurf, French,8},
  
    { "&Fildiferro",                                     StrMWirefr,  Italian,0},
    { "&Scheletro",                                      StrMBackbn,  Italian,0},
***************
*** 904,909 ****
--- 911,917 ----
    { "&Nastri",                                         StrMRibbons, Italian,0},
    { "&Fili",                                           StrMStrands, Italian,0},
    { "&Vignetta",                                       StrMCartoon, Italian,0},
+   { "Superficie &Molecolare",                          StrMMolSurf, Italian,11},
  
    { "&Monochrome",                                     StrMMonochr, English,0},
    { "&CPK",                                            StrMCPK,     English,0},
***************
*** 1153,1160 ****
  
    { "Nome documento PDB:",                             StrPrmtPDB,  Italian,0},
    { "Nome documento immagine:",                        StrPrmtImg,  Italian,0},
!   { "Nome documento molecola:",                        StrPrmtMol,  Italian,0}
  
    
  };
   
--- 1161,1177 ----
  
    { "Nome documento PDB:",                             StrPrmtPDB,  Italian,0},
    { "Nome documento immagine:",                        StrPrmtImg,  Italian,0},
!   { "Nome documento molecola:",                        StrPrmtMol,  Italian,0},
  
+   { "Warning: ",                                       StrWarn,     English,0},
+   { "Cuidado: ",                                       StrWarn,     Spanish,0},
+   { "Avertissement: ",                                 StrWarn,     French,0},
+   { "Attenzione: ",                                    StrWarn,     Italian,0},
+ 
+   { "Chain",                                           StrChain,    English,0},
+   { "Cadena",                                          StrChain,    Spanish,0},
+   { "Chaîne",                                          StrChain,    French,0},
+   { "Catena",                                          StrChain,    Italian,0}
    
  };
   
*** langsel.h	2004/05/07 19:46:16	1.1
--- langsel.h	2005/01/16 20:25:16
***************
*** 168,248 ****
         StrMRibbons =   95,
         StrMStrands =   96,
         StrMCartoon =   97,
  
!        StrMMonochr =   98,
!        StrMCPK     =   99,
!        StrMShapely =  100,
!        StrMGroup   =  101,
!        StrMChain   =  102,
!        StrMTemp    =  103,
!        StrMStruct  =  104,
!        StrMUser    =  105,
!        StrMModel   =  106,
!        StrMAlt     =  107,
! 
!        StrMSlab    =  108,
!        StrMHydr    =  109,
!        StrMHet     =  110,
!        StrMSpec    =  111,
!        StrMShad    =  112,
!        StrMStereo  =  113,
!        StrMLabel   =  114,
!        
!        StrMPOff    =  115,
!        StrMPIdent  =  116,
!        StrMPDist   =  117,
!        StrMPMon    =  118,
!        StrMPAng    =  119,
!        StrMPTrsn   =  120,
!        StrMPLabl   =  121,
!        StrMPCent   =  122,
!        StrMPCoord  =  123,
!        StrMPBond   =  124,
!        StrMRBond   =  125,
!        StrMRMol    =  126,
!        StrMRAll    =  127,
! 
!        StrMGIF     =  128,
!        StrMPostscr =  129,
!        StrMPPM     =  130,
!        StrMIRGB    =  131,
!        StrMSRast   =  132,
!        StrMBMP     =  133,
!        StrMPICT    =  134,
! 
!        StrMAbout   =  135,
!        StrMUserM   =  136,
!        
!        StrMUndo    =  137,
!        StrMCut     =  138,
!        StrMCopy    =  139,
!        StrMPaste   =  140,
  #ifdef APPLEMAC
!        StrMClear   =  141,
  #else
!        StrMDelete  =  141,
  #endif
!        StrMSelAll  =  142,
  
!        StrMFile    =  143,
!        StrMEdit    =  144,
!        StrMDisplay =  145,
!        StrMColour  =  146,
!        StrMOpt     =  147,
!        StrMSettings=  148,
!        StrMExport  =  149,
  #ifdef APPLEMAC
!        StrMWindow  =  150,
!        StrMHelp    =  151,
!        StrMMainWin =  152,
!        StrMCmndLin =  153,
  #else
!        StrMHelp    =  150,
  #endif
  
!        StrPrmtPDB  =  154,
!        StrPrmtImg  =  155,
!        StrPrmtMol  =  156
  
  
  } strflag;
--- 168,251 ----
         StrMRibbons =   95,
         StrMStrands =   96,
         StrMCartoon =   97,
+        StrMMolSurf =   98,
  
!        StrMMonochr =   99,
!        StrMCPK     =  100,
!        StrMShapely =  101,
!        StrMGroup   =  102,
!        StrMChain   =  103,
!        StrMTemp    =  104,
!        StrMStruct  =  105,
!        StrMUser    =  106,
!        StrMModel   =  107,
!        StrMAlt     =  108,
! 
!        StrMSlab    =  109,
!        StrMHydr    =  110,
!        StrMHet     =  111,
!        StrMSpec    =  112,
!        StrMShad    =  113,
!        StrMStereo  =  114,
!        StrMLabel   =  115,
!        
!        StrMPOff    =  116,
!        StrMPIdent  =  117,
!        StrMPDist   =  118,
!        StrMPMon    =  119,
!        StrMPAng    =  120,
!        StrMPTrsn   =  121,
!        StrMPLabl   =  122,
!        StrMPCent   =  123,
!        StrMPCoord  =  124,
!        StrMPBond   =  125,
!        StrMRBond   =  126,
!        StrMRMol    =  127,
!        StrMRAll    =  128,
! 
!        StrMGIF     =  129,
!        StrMPostscr =  130,
!        StrMPPM     =  131,
!        StrMIRGB    =  132,
!        StrMSRast   =  133,
!        StrMBMP     =  134,
!        StrMPICT    =  135,
! 
!        StrMAbout   =  136,
!        StrMUserM   =  137,
!        
!        StrMUndo    =  138,
!        StrMCut     =  139,
!        StrMCopy    =  140,
!        StrMPaste   =  141,
  #ifdef APPLEMAC
!        StrMClear   =  142,
  #else
!        StrMDelete  =  142,
  #endif
!        StrMSelAll  =  143,
  
!        StrMFile    =  144,
!        StrMEdit    =  145,
!        StrMDisplay =  146,
!        StrMColour  =  147,
!        StrMOpt     =  148,
!        StrMSettings=  149,
!        StrMExport  =  150,
  #ifdef APPLEMAC
!        StrMWindow  =  151,
!        StrMHelp    =  152,
!        StrMMainWin =  153,
!        StrMCmndLin =  154,
  #else
!        StrMHelp    =  151,
  #endif
  
!        StrPrmtPDB  =  155,
!        StrPrmtImg  =  156,
!        StrPrmtMol  =  157,
!        StrWarn     =  158,
!        StrChain    =  159
  
  
  } strflag;
*** langsel_mac.c	2004/05/07 19:46:16	1.1
--- langsel_mac.c	2005/01/16 20:25:17
***************
*** 525,530 ****
--- 525,531 ----
    { "Ribbons",                                         StrMRibbons, English,0},
    { "Strands",                                         StrMStrands, English,3},
    { "Cartoons",                                        StrMCartoon, English,0},
+   { "Molecular Surface",                               StrMMolSurf, English,0},
  
    { "Alambre",                                         StrMWirefr,  Spanish,0},
    { "Esqueleto",                                       StrMBackbn,  Spanish,0},
***************
*** 534,539 ****
--- 535,541 ----
    { "Cintas",                                          StrMRibbons, Spanish,0},
    { "Hebras",                                          StrMStrands, Spanish,0},
    { "Dibujo",                                          StrMCartoon, Spanish,0},
+   { "Superficie Molecular",                            StrMMolSurf, Spanish,11},
  
    { "Fil",                                             StrMWirefr,  French,0},
    { "Squelette",                                       StrMBackbn,  French,0},
***************
*** 543,548 ****
--- 545,551 ----
    { "Rubans",                                          StrMRibbons, French,0},
    { "Tresses",                                         StrMStrands, French,0},
    { "Ebauches",                                        StrMCartoon, French,5},
+   { "Surface MolŽcular",                               StrMMolSurf, French,8},
  
    { "Fildiferro",                                      StrMWirefr,  Italian,0},
    { "Scheletro",                                       StrMBackbn,  Italian,0},
***************
*** 552,557 ****
--- 555,561 ----
    { "Nastri",                                          StrMRibbons, Italian,0},
    { "Fili",                                            StrMStrands, Italian,0},
    { "Vignetta",                                        StrMCartoon, Italian,0},
+   { "Superficie Molecolare",                           StrMMolSurf, Italian,11},
  
    { "Monochrome",                                      StrMMonochr, English,0},
    { "CPK",                                             StrMCPK,     English,0},
***************
*** 877,882 ****
--- 881,887 ----
    { "&Ribbons",                                        StrMRibbons, English,0},
    { "Str&ands",                                        StrMStrands, English,3},
    { "&Cartoons",                                       StrMCartoon, English,0},
+   { "&Molecular Surface",                              StrMMolSurf, English,0},  
  
    { "&Alambre",                                        StrMWirefr,  Spanish,0},
    { "&Esqueleto",                                      StrMBackbn,  Spanish,0},
***************
*** 886,891 ****
--- 891,897 ----
    { "&Cintas",                                         StrMRibbons, Spanish,0},
    { "&Hebras",                                         StrMStrands, Spanish,0},
    { "&Dibujo",                                         StrMCartoon, Spanish,0},
+   { "Superficie &Molecular",                           StrMMolSurf, Spanish,11},
  
    { "&Fil",                                            StrMWirefr,  French,0},
    { "&Squelette",                                      StrMBackbn,  French,0},
***************
*** 895,900 ****
--- 901,907 ----
    { "&Ribbons",                                        StrMRibbons, French,0},
    { "&Tresses",                                        StrMStrands, French,0},
    { "Ebauc&hes",                                       StrMCartoon, French,5},
+   { "Surface &MolŽcular",                              StrMMolSurf, French,8},
  
    { "&Fildiferro",                                     StrMWirefr,  Italian,0},
    { "&Scheletro",                                      StrMBackbn,  Italian,0},
***************
*** 904,909 ****
--- 911,917 ----
    { "&Nastri",                                         StrMRibbons, Italian,0},
    { "&Fili",                                           StrMStrands, Italian,0},
    { "&Vignetta",                                       StrMCartoon, Italian,0},
+   { "Superficie &Molecolare",                          StrMMolSurf, Italian,11},
  
    { "&Monochrome",                                     StrMMonochr, English,0},
    { "&CPK",                                            StrMCPK,     English,0},
***************
*** 1153,1159 ****
    
    { "Nome documento PDB:",                             StrPrmtPDB,  Italian,0},
    { "Nome documento immagine:",                        StrPrmtImg,  Italian,0},
!   { "Nome documento molecola:",                        StrPrmtMol,  Italian,0}
  
    
  };
--- 1161,1179 ----
    
    { "Nome documento PDB:",                             StrPrmtPDB,  Italian,0},
    { "Nome documento immagine:",                        StrPrmtImg,  Italian,0},
!   { "Nome documento molecola:",                        StrPrmtMol,  Italian,0},
! 
!   { "Warning: ",                                       StrWarn,     English,0},
!   { "Cuidado: ",                                       StrWarn,     Spanish,0},
!   { "Avertissement: ",                                 StrWarn,     French,0},
!   { "Attenzione: ",                                    StrWarn,     Italian,0},
! 
!   { "Chain",                                           StrChain,    English,0},
!   { "Cadena",                                          StrChain,    Spanish,0},
!   { "Cha”ne",                                          StrChain,    French,0},
!   { "Catena",                                          StrChain,    Italian,0}
! 
! 
  
    
  };
*** molecule.c	2004/05/07 19:46:16	1.1
--- molecule.c	2005/01/21 02:16:46
***************
*** 133,138 ****
--- 142,148 ----
  #include "transfor.h"
  #include "render.h"
  #include "langsel.h"
+ #include "repres.h"
  #include "graphics.h"
  
  #define HBondPool   32
***************
*** 145,154 ****
  
  #define Cos70Deg     0.34202014332567
  
! #define MaxHBondDist   ((Long)300*300)
! #define MaxBondDist    ((Long)475*475)
! #define MinBondDist    ((Long)100*100)
! #define AbsMaxBondDist 600
  
  #ifdef APPLEMAC
  #define AllocSize   256
--- 155,170 ----
  
  #define Cos70Deg     0.34202014332567
  
! #define MaxHBondDist   ((int)300)
! #define MaxBondDist    ((int)475)
! #define MinBondDist    ((int)100)
! 
! #define MaxHBondDsq    ((Long)(MaxHBondDist*MaxHBondDist))
! #define MaxBondDsq     ((Long)(MaxBondDist*MaxBondDist))
! #define MinBondDsq     ((Long)(MinBondDist*MinBondDist))
! #define AbsMaxBondDist 600      /* 2.4 Angstroms */
! #define AbsMaxAtomRad  750      /* 3.0 Angstroms */
! #define AbsMaxAtomDiam AbsMaxAtomRad*2
  
  #ifdef APPLEMAC
  #define AllocSize   256
***************
*** 371,376 ****
--- 387,393 ----
          CurMolecule->slist = (void __far*)0;
          CurMolecule->hlist = (void __far*)0;
          CurMolecule->blist = (void __far*)0;
+         CurMolecule->sblist = (void __far*)0;
          CurMolecule->clist = (void __far*)0;
          Database = CurMolecule;
      }
***************
*** 1224,1235 ****
--- 1243,1304 ----
      ptr->aradius = 0;
      ptr->iarad = 0;
      ptr->col = 0;
+ 
      ptr->altl = '\0';
      if (src && src->altl != '\0' && src->altl != ' ') ptr->altl = src->altl;
      if (dst && dst->altl != '\0' && dst->altl != ' ') ptr->altl = dst->altl;
  
      return ptr;
  }
+ SurfBond __far *ProcessSurfBond( RAtom __far *src, RAtom __far *dst )
+ {
+     register SurfBond __far *ptr;
+     register int i;
+     register Long lx, ly, lz, lxyzsq;
+     register Long xrad1, xrad2, wpsq;
+ 
+     DrawSurf = True;
+ 
+     if( !(ptr = FreeSurfBond) )
+     {   MemSize += BondPool*sizeof(SurfBond);
+         ptr = (SurfBond __far *)_fmalloc( BondPool*sizeof(SurfBond) );
+         if( !ptr ) FatalDataError(MsgStrs[StrMalloc]);
+         RegisterAlloc( ptr );
+         for( i=1; i<BondPool; i++ )
+         {   ptr->sbnext = FreeSurfBond;
+             FreeSurfBond = ptr++;
+         } 
+     } else FreeSurfBond = ptr->sbnext;
+ 
+     ptr->srcatom = src;
+     ptr->dstatom = dst;
+     ptr->col = 0;
+ 
+     ptr->altl = '\0';
+     if (src && src->altl != '\0' && src->altl != ' ') ptr->altl = src->altl;
+     if (dst && dst->altl != '\0' && dst->altl != ' ') ptr->altl = dst->altl;
+     lx = src->xorg+src->fxorg-dst->xorg-dst->fxorg;
+     ly = src->yorg+src->fyorg-dst->yorg-dst->fyorg;
+     lz = src->zorg+src->fzorg-dst->zorg-dst->fzorg;
+     lxyzsq = lx*lx + ly*ly + lz*lz;
+     ptr->sxyz = (Long)(sqrt((double)lxyzsq)+.5);
+     xrad1 = src->radius;
+     xrad2 = dst->radius;
+     ptr->u1 = ((ptr->sxyz)+
+       (((((xrad1+xrad2+(ProbeRadius+ProbeRadius))*
+       (xrad1-xrad2)))/ptr->sxyz))+1)>>1;
+     /* if (ptr->u1 > ptr->sxyz) ptr->u1 = ptr->sxyz; */
+     ptr->u2 = ptr->sxyz-ptr->u1;
+     wpsq = ((((xrad1+ProbeRadius))*((xrad1+ProbeRadius))))
+       -ptr->u1*ptr->u1;
+     if (wpsq < 0 ) wpsq = 0;
+     ptr->wp = (Long)rint(sqrt((double)wpsq));
+     ptr->t1 = (ptr->u1*xrad1)/(xrad1+ProbeRadius);
+     ptr->t2 = (ptr->u2*xrad2)/(xrad2+ProbeRadius);
+     ptr->w1 = (ptr->wp*xrad1)/(xrad1+ProbeRadius);
+     ptr->w2 = (ptr->wp*xrad2)/(xrad2+ProbeRadius);
+     return ptr;
+ }
  
  static void CreateHydrogenBond( RAtom __far *srcCA, RAtom __far *dstCA,
                                  RAtom __far *src, RAtom __far *dst,
***************
*** 1262,1267 ****
--- 1331,1337 ----
      ptr->dstCA = dstCA;
      ptr->energy = energy;
      ptr->col = 0;
+ 
      ptr->altl = '\0';
      if (src && src->altl != '\0' && src->altl != ' ') ptr->altl = src->altl;
      if (dst && dst->altl != '\0' && dst->altl != ' ') ptr->altl = dst->altl;
***************
*** 1418,1423 ****
--- 1488,1664 ----
      CreateBond( src, dst, NormBondFlag );
  }
  
+ /* PreTestSurface
+       sptr -- pointer to source atom
+ 	  dptr -- pointer to destination atom
+ 	  C    -- an array to receive the center of the
+ 	          intersection circle of the probe-radius
+ 		      extended atoms
+ 	  crad -- pointer to the radius of the intersection
+ 	          circle of the probe-radius extended
+ 			  atoms
+ 	  Un   -- an array of the normalized axis from
+ 	          sptr to dptr, scaled by 4096 (2**12)
+ 	  
+ 	  returns -- 
+ 	          -1 if the atoms are too far apart for
+ 			     the probe to touch
+ 			   0 if the atoms can be touched by the
+ 			     probe, but do not overlap
+ 			   1 if the atoms overlap (centers
+ 				 within the average of the radii)
+  */
+ 
+ 
+ static int PreTestSurface(  RAtom __far *sptr,  RAtom __far *dptr, 
+       Long C[3],  int *crad, Long Un[3] )
+ {
+     register Long dx, dy, dz;
+     register Long maxS, maxT, dist;
+     register int srad,drad;
+ 	Long lx, ly, lz, lxyzsq, sxyz, u1, rat, wpsq;
+ 
+     if ( !(sptr->model == dptr->model) ) return -1;
+     if ( !(sptr->altl == ' ' || sptr->altl == '\0') &&
+          !(dptr->altl == ' ' || dptr->altl == '\0') &&
+          !(sptr->altl == dptr->altl) ) return -1;
+     srad = sptr->radius;
+     drad = dptr->radius;
+     if (srad < 10 ) srad = Element[sptr->elemno].vdwrad;
+     if (drad < 10 ) drad = Element[dptr->elemno].vdwrad;
+     
+     /* Sum of van der Waals radii */
+ 	dist = srad + drad;
+ 	maxT = dist*dist/4;
+     dist += ProbeRadius+ProbeRadius;
+     maxS = dist*dist;  
+     
+     dx = sptr->xorg-dptr->xorg 
+          + sptr->fxorg-dptr->fxorg;   if( (dist=dx*dx)>=maxS ) return -1;
+     dy = sptr->yorg-dptr->yorg
+          + sptr->fyorg-dptr->fyorg;   if( (dist+=dy*dy)>=maxS ) return -1;
+     dz = sptr->zorg-dptr->zorg
+          + sptr->fzorg-dptr->fzorg;   if( (dist+=dz*dz)>=maxS ) return -1;
+ 
+ 	lx = sptr->xorg+sptr->fxorg-dptr->xorg-dptr->fxorg;
+     ly = sptr->yorg+sptr->fyorg-dptr->yorg-dptr->fyorg;
+     lz = sptr->zorg+sptr->fzorg-dptr->zorg-dptr->fzorg;
+     lxyzsq = lx*lx + ly*ly + lz*lz;
+     sxyz = (Long)(sqrt((double)lxyzsq)+.5);
+     u1 = (sxyz+
+       (((((srad+drad+(ProbeRadius+ProbeRadius))*
+       (srad-drad)))/sxyz))+1)>>1;
+ 	rat = (4096*u1)/sxyz;
+ 	C[0] = (rat*(sptr->xorg+sptr->fxorg)+(4096-rat)*(dptr->xorg+dptr->fxorg))/4096;
+ 	C[1] = (rat*(sptr->yorg+sptr->fyorg)+(4096-rat)*(dptr->yorg+dptr->fyorg))/4096;
+ 	C[2] = (rat*(sptr->zorg+sptr->fzorg)+(4096-rat)*(dptr->zorg+dptr->fzorg))/4096;
+     wpsq = ((((srad+ProbeRadius))*((srad+ProbeRadius))))
+       -u1*u1;
+     if (wpsq < 0 ) wpsq = 0;
+     *crad = (Long)rint(sqrt((double)wpsq));
+ 	Un[0] = -(lx*4096)/sxyz;
+ 	Un[1] = -(ly*4096)/sxyz;
+ 	Un[2] = -(lz*4096)/sxyz;
+ 
+ 	if (dist > maxT ) return 0;
+ 	return 1;	
+ 
+ }
+ 
+ 
+ static void TestSurface(  RAtom __far *sptr,  RAtom __far *dptr )
+ {
+     register SurfBond __far *sbptr;
+     register Long dx, dy, dz;
+     register Long maxS, dist;
+     register int srad,drad;
+ 
+     if ( !(sptr->model == dptr->model) ) return;
+     if ( !(sptr->altl == ' ' || sptr->altl == '\0') &&
+          !(dptr->altl == ' ' || dptr->altl == '\0') &&
+          !(sptr->altl == dptr->altl) ) return;
+     srad = sptr->radius;
+     drad = dptr->radius;
+     if (srad < 10 ) srad = Element[sptr->elemno].vdwrad;
+     if (drad < 10 ) drad = Element[dptr->elemno].vdwrad;
+     
+     /* Sum of van der Walls radii */
+     dist = srad + drad + ProbeRadius+ProbeRadius;
+     maxS = dist*dist;  
+     
+     dx = sptr->xorg-dptr->xorg 
+          + sptr->fxorg-dptr->fxorg;   if( (dist=dx*dx)>=maxS ) return;
+     dy = sptr->yorg-dptr->yorg
+          + sptr->fyorg-dptr->fyorg;   if( (dist+=dy*dy)>=maxS ) return;
+     dz = sptr->zorg-dptr->zorg
+          + sptr->fzorg-dptr->fzorg;   if( (dist+=dz*dz)>=maxS ) return;
+ 
+     if( dist > (srad+drad-ProbeRadius)*(srad+drad-ProbeRadius) )
+     {   /* Reset Non-bonded flags! */
+         sptr->flag &= ~NonBondFlag;
+         dptr->flag &= ~NonBondFlag;
+ 
+         sbptr = ProcessSurfBond(sptr,dptr);
+         sbptr->sbnext = CurMolecule->sblist;
+         CurMolecule->sblist = sbptr;
+         Info.srfbondcount++;
+     }
+ }
+ 
+ /*
+     TestBuriedSurface
+ 	    aprt -- pointer to one atom of the pair being checked
+ 		dprt -- pointer to the other atom of the par being checked
+ 		eptr -- an atom that might bury the surface bond
+ 		C    -- the center of the circle at the neck of the surface bond
+ 		crad -- the radius of the orbit of the probe center around C
+ 		Un   -- the unit normal *4096 of the axis of the surface bond
+  */
+ 
+ static int TestBuriedSurface( RAtom __far *aptr, RAtom __far *dptr, RAtom __far *eptr, 
+                               Long C[3], int crad, Long Un[3]) { 
+ 
+  
+ 	register Long dx, dy, dz;
+     register Long maxS, dist, dec, decun;
+     register int erad;
+ 	Long ECxUn[3];
+ 
+     if ( eptr->model != aptr->model ) return -1; // different models cannot bury each other
+     if ( ( eptr->altl != ' ' && aptr->altl != ' ' && eptr->altl != aptr->altl) ||
+ 	     ( eptr->altl != ' ' && dptr->altl != ' ' && eptr->altl != dptr->altl) ) return -1;
+     erad = eptr->radius;
+     if (erad < 10 ) erad = Element[eptr->elemno].vdwrad;
+     
+     /* Sum of van der Walls radii */
+     dist = erad + crad + ProbeRadius;
+     maxS = dist*dist;  
+     
+     dx = eptr->xorg-C[0] 
+          + eptr->fxorg;   if( (dist=dx*dx)>=maxS ) return -1;
+     dy = eptr->yorg-C[1]
+          + eptr->fyorg;   if( (dist+=dy*dy)>=maxS ) return -1;
+     dz = eptr->zorg-C[2]
+          + eptr->fzorg;   if( (dist+=dz*dz)>=maxS ) return -1;
+ 
+     // Compute the cross product of (E-C)XUn 
+     ECxUn[0] = dy*Un[2]-dz*Un[1];
+ 	ECxUn[1] = dz*Un[0]-dx*Un[2];
+ 	ECxUn[2] = dx*Un[1]-dy*Un[0];
+ 	
+ 	// Compute the hypotenuse
+ 	
+ 	dec = (Long)(rint(4096*sqrt((double)dist)));
+ 	decun = (Long)(rint(sqrt((double)(ECxUn[0]*ECxUn[0] + ECxUn[1]*ECxUn[1] + ECxUn[2]*ECxUn[2]))));
+ 	dist += crad*crad + (2*crad*decun)/dec;
+ 	/* fprintf(stderr,"TBS E-C = {%ld,%ld,%ld} C={%ld,%ld,%ld}, re=%d, wp=%d, c=%ld,a=%ld,h=%d\n",
+ 	      dx, dy, dz, C[0],C[1],C[2],erad+ProbeRadius, crad, dec/4096,crad*decun/dec,
+ 		  (int)sqrt((double)dist)); */
+ 	if (dist < (erad+ProbeRadius)*(erad+ProbeRadius)) return 0;
+     
+     return 1;
+ } 
+ 
  
  static void TestBonded(  RAtom __far *sptr,  RAtom __far *dptr, int flag )
  {
***************
*** 1437,1444 ****
      } else 
      {    /* Fast Bio-Macromolecule Bonding Calculation */
           if( (sptr->flag|dptr->flag) & HydrogenFlag )
!          {      max = MaxHBondDist;
!          } else max = MaxBondDist;
      }
      
      dx = sptr->xorg-dptr->xorg 
--- 1678,1685 ----
      } else 
      {    /* Fast Bio-Macromolecule Bonding Calculation */
           if( (sptr->flag|dptr->flag) & HydrogenFlag )
!          {      max = MaxHBondDsq;
!          } else max = MaxBondDsq;
      }
      
      dx = sptr->xorg-dptr->xorg 
***************
*** 1448,1454 ****
      dz = sptr->zorg-dptr->zorg
           + sptr->fzorg-dptr->fzorg;   if( (dist+=dz*dz)>max ) return;
  
!     if( dist > MinBondDist )
      {   /* Reset Non-bonded flags! */
          sptr->flag &= ~NonBondFlag;
          dptr->flag &= ~NonBondFlag;
--- 1689,1695 ----
      dz = sptr->zorg-dptr->zorg
           + sptr->fzorg-dptr->fzorg;   if( (dist+=dz*dz)>max ) return;
  
!     if( dist > MinBondDsq )
      {   /* Reset Non-bonded flags! */
          sptr->flag &= ~NonBondFlag;
          dptr->flag &= ~NonBondFlag;
***************
*** 1473,1483 ****
          FreeHBond = ptr;
      }
  }
  
  
! static void ReclaimBonds( Bond __far *ptr )
  {
      register Bond __far *temp;
  
      if( ptr )
      {   temp = ptr;
--- 1714,1742 ----
          FreeHBond = ptr;
      }
  }
+ static void ReclaimSurfBonds( Molecule __far *Mol)
+ {
+     register SurfBond __far *ptr;
+     register SurfBond __far *temp;
  
+     ptr = Mol->sblist;
  
!     if( ptr )
!     {   temp = ptr;
!         while( temp->sbnext )
!             temp=temp->sbnext;
!         temp->sbnext = FreeSurfBond;
!         FreeSurfBond = ptr;
!     }
!     Mol->sblist = (SurfBond __far*)0;
! }
! 
! 
! static void ReclaimBonds( Molecule __far *Mol)
  {
+     register Bond __far *ptr;
      register Bond __far *temp;
+     ptr = Mol->blist;
  
      if( ptr )
      {   temp = ptr;
***************
*** 1486,1491 ****
--- 1745,1767 ----
          temp->bnext = FreeBond;
          FreeBond = ptr;
      }
+     Mol->blist = (Bond __far*)0;
+ }
+ 
+ static void ReclaimChainBonds( Chain __far *Chn)
+ {
+     register Bond __far *ptr;
+     register Bond __far *temp;
+     ptr = Chn->blist;
+ 
+     if( ptr )
+     {   temp = ptr;
+         while( temp->bnext )
+             temp=temp->bnext;
+         temp->bnext = FreeBond;
+         FreeBond = ptr;
+     }
+     Chn->blist = (Bond __far*)0;
  }
  
  
***************
*** 1521,1530 ****
                 + src->fzorg-dst->fzorg; dist += dz*dz;
          }
  
!         if( (temp->flag & NormBondFlag) &&  !(dist > max) )
          {   temp->bnext = FreeBond;
              FreeBond = temp;
!         } else /* Long or Double or Triple! */
          {   temp->bnext = result;
              result = temp;
          }
--- 1797,1806 ----
                 + src->fzorg-dst->fzorg; dist += dz*dz;
          }
  
!         if( ((temp->flag & NormBondFlag) &&  !(dist > max)))
          {   temp->bnext = FreeBond;
              FreeBond = temp;
!         } else /* Long or Double or Triple or Aromatic */
          {   temp->bnext = result;
              result = temp;
          }
***************
*** 1584,1591 ****
  
      /* Save Explicit Long, Double and Triple Bonds on File Load */
      list = (Bond __far*)0;
!     if (!force)
        list = ExtractBonds( CurMolecule->blist );
      CurMolecule->blist = (Bond __far*)0;
      Info.bondcount = 0;
  
--- 1860,1871 ----
  
      /* Save Explicit Long, Double and Triple Bonds on File Load */
      list = (Bond __far*)0;
!     if (!force) {
        list = ExtractBonds( CurMolecule->blist );
+     }
+      /* else {
+       ReclaimBonds (CurMolecule);
+     } */
      CurMolecule->blist = (Bond __far*)0;
      Info.bondcount = 0;
  
***************
*** 1655,1660 ****
--- 1935,2119 ----
  }
  
  
+ void CreateSurfaceBonds( void )
+ {
+     register int i, x, y, z, im, xm, ym, zm;
+     register Long tx, ty, tz;
+     register Long txm, tym, tzm;
+     register Long mx, my, mz; 
+     register Long mxm, mym, mzm; 
+     register Long dx, dy, dz;
+     register int lx, ly, lz, ux, uy, uz;
+     register int lxm, lym, lzm, uxm, uym, uzm;
+     register RAtom __far *aptr, __far *dptr, __far *eptr;
+     register Chain __far *chain;
+     register Group __far *group;
+     register Long voxorder, voxorder2;
+ 	register SurfBond __far *sbptr;
+ 	Long C[3], Un[3];
+ 	int crad;
+ 	
+     if( !Database ) 
+         return;
+ 	
+     dx = (MaxX-MinX)+1;
+     dy = (MaxY-MinY)+1;
+     dz = (MaxZ-MinZ)+1;
+ 	
+     ReclaimSurfBonds( CurMolecule );
+     CurMolecule->sblist = (SurfBond __far*)0;
+     Info.srfbondcount = 0;
+ 	
+     ResetVoxelData();
+ 	
+     voxorder = VOXORDER;
+     voxorder2 =VOXORDER2;
+ 	
+     if ( dx+749 < 750*VOXORDER && 
+          dy+749 < 750*VOXORDER && 
+          dz+749 < 750*VOXORDER ) {
+ 		voxorder = (dx+749)/750;
+ 		if (dy > dx && dy > dz) voxorder = (dy+749)/750;
+ 		if (dz > dx && dz > dy) voxorder = (dz+749)/750;
+ 		voxorder2 = voxorder*voxorder;
+     } 
+ 	
+     /* Load the hash table with all selected atoms and
+ 		clear SurfBondFlag */
+ 	
+     for( chain=Database->clist; chain; chain=chain->cnext ) {
+         for( group=chain->glist; group; group=group->gnext ) {
+             for( aptr=group->alist; aptr; aptr=aptr->anext ) {
+ 				if (aptr->flag&SelectFlag) {  
+ 					
+ 					mx = aptr->xorg + aptr->fxorg - MinX;
+ 					my = aptr->yorg + aptr->fyorg - MinY;
+ 					mz = aptr->zorg + aptr->fzorg - MinZ;
+ 					
+ 					x = (int)((voxorder*mx)/dx);
+ 					y = (int)((voxorder*my)/dy);
+ 					z = (int)((voxorder*mz)/dz);
+ 					
+ 					i = voxorder2*x + voxorder*y + z;
+ 					aptr->next = (RAtom __far*)HashTable[i];
+ 					aptr->flag &= ~SurfBondFlag;
+ 					HashTable[i] = (void __far*)aptr;
+ 				}
+ 				VoxelsClean = False;
+ 			}
+ 		}
+ 	}
+ 	
+     /* Now run through the atoms again and check each atom
+ 		against the others using the hash table */
+ 	
+     for( chain=Database->clist; chain; chain=chain->cnext ) {
+         for( group=chain->glist; group; group=group->gnext ) {
+             for( aptr=group->alist; aptr; aptr=aptr->anext ) {
+ 				if (aptr->flag&SelectFlag && (!(aptr->flag&ExpandFlag))) {
+ 					
+ 					/* Look for atoms within 6 Angstroms plus 2
+ 					probe radii of atom aptr */
+ 					
+ 					mx = aptr->xorg + aptr->fxorg - MinX;
+ 					my = aptr->yorg + aptr->fyorg - MinY;
+ 					mz = aptr->zorg + aptr->fzorg - MinZ;
+ 					
+ 					tx = mx-AbsMaxAtomDiam-ProbeRadius-ProbeRadius;  
+ 					ty = my-AbsMaxAtomDiam-ProbeRadius-ProbeRadius;  
+ 					tz = mz-AbsMaxAtomDiam-ProbeRadius-ProbeRadius;  
+ 					
+ 					lx = (tx>0)? (int)((voxorder*tx)/dx) : 0;
+ 					ly = (ty>0)? (int)((voxorder*ty)/dy) : 0;
+ 					lz = (tz>0)? (int)((voxorder*tz)/dz) : 0;
+ 					
+ 					tx = mx+AbsMaxAtomDiam+ProbeRadius+ProbeRadius;  
+ 					ty = my+AbsMaxAtomDiam+ProbeRadius+ProbeRadius;  
+ 					tz = mz+AbsMaxAtomDiam+ProbeRadius+ProbeRadius;
+ 					
+ 					ux = (tx<dx)? (int)((voxorder*tx)/dx) : voxorder-1;
+ 					uy = (ty<dy)? (int)((voxorder*ty)/dy) : voxorder-1;
+ 					uz = (tz<dz)? (int)((voxorder*tz)/dz) : voxorder-1;
+ 					
+ 					for( x = lx; x <= ux; x++ ) { 
+ 						i = voxorder2*x + voxorder*ly;
+ 						for( y = ly; y<=uy; y++ ) {   
+ 							for( z = lz; z<=uz; z++ ) {
+ 							    register int abort; 
+ 								dptr = (RAtom __far*)HashTable[i+z];
+ 								while( dptr ) {
+ 								  if( dptr->serno <  aptr->serno ) { 
+ 									
+ 									abort = 0;
+ 									switch (PreTestSurface(aptr,dptr,C,&crad,Un)) {
+ 										
+ 										case 0: 
+ 											/* Look for atoms centers within ProbeRadius+AbsMaxAtomRad of C
+ 											i.e. 3 Angstroms plus the ProbeRadius of C */ 
+ 											mxm = C[0] - MinX; 
+ 											mym = C[1] - MinY; 
+ 											mzm = C[2] - MinZ;
+ 											
+ 											txm = mx-AbsMaxAtomRad-ProbeRadius;  
+ 											tym = my-AbsMaxAtomRad-ProbeRadius;  
+ 											tzm = mz-AbsMaxAtomRad-ProbeRadius;  
+ 											
+ 											lxm = (txm>0)? (int)((voxorder*txm)/dx) : 0;
+ 											lym = (tym>0)? (int)((voxorder*tym)/dy) : 0;
+ 											lzm = (tzm>0)? (int)((voxorder*tzm)/dz) : 0;
+ 											
+ 											txm = mxm+AbsMaxAtomRad+ProbeRadius; 
+ 											tym = mym+AbsMaxAtomRad+ProbeRadius;  
+ 											tzm = mzm+AbsMaxAtomRad+ProbeRadius;
+ 											
+ 											uxm = (txm<dx)? (int)((voxorder*txm)/dx) : voxorder-1;
+ 											uym = (tym<dy)? (int)((voxorder*tym)/dy) : voxorder-1;
+ 											uzm = (tzm<dz)? (int)((voxorder*tzm)/dz) : voxorder-1;
+ 											
+ 											for ( xm = lxm; (xm < uxm&& !abort) ; xm++ ) { 
+ 												im = voxorder2*xm + voxorder*lym;
+ 												for ( ym = lym; (ym<=uym && !abort) ; ym++ ) {   
+ 													for( zm = lz; (zm<=uzm && !abort); zm++ ) {
+ 														eptr = (RAtom __far*)HashTable[im+zm];
+ 														while( eptr && (eptr != dptr)  && (eptr != aptr) && !abort ) {
+ 															if (!TestBuriedSurface(aptr,dptr,eptr,C,crad,Un)) {  
+ 																abort = 1;
+ 																break;
+ 															}
+ 															eptr = eptr->next;
+ 														}
+ 													}
+ 													im += voxorder;
+ 												}
+ 											}
+ 												
+ 											break;
+ 										case 1:  abort = 0;
+ 											break;
+ 										case -1: abort = -1;
+ 											break;
+ 									}
+ 									if ( !abort ) {
+ 										sbptr = ProcessSurfBond(aptr,dptr);
+ 										sbptr->sbnext = CurMolecule->sblist;
+ 										CurMolecule->sblist = sbptr;
+ 										Info.srfbondcount++;
+ 									}
+ 								  }
+ 								  dptr = dptr->next;
+                                 }
+                             }
+                             i += voxorder;
+                         }
+ 					}
+                 }
+             }
+         }
+     }
+ 
+ }
+ 
+ 
  
  /*=================================*/
  /*  Disulphide bridging functions  */
***************
*** 1737,1742 ****
--- 2196,2202 ----
  
      if( !Database ) return;
      ReclaimHBonds( CurMolecule->slist );
+     CurMolecule->slist = (HBond __far*)0;
      Info.ssbondcount = 0;
  
      for(chn1=Database->clist;chn1;chn1=chn1->cnext)
***************
*** 2205,2212 ****
          hnextj = hnextj->hnext;
  
      while( chain )
!     {   if( nextj ) 
!             {
              if( IsProtein(chain->glist->refno) )
              {   count = 1;
                  do {
--- 2665,2671 ----
          hnextj = hnextj->hnext;
  
      while( chain )
!     {   if( nextj ) {
              if( IsProtein(chain->glist->refno) )
              {   count = 1;
                  do {
***************
*** 2242,2251 ****
  	            nextj = nextj->gnext;
  		} while( nextj );
  
! 	    } else if( IsNucleo(chain->glist->refno) )
! 		while( hnextj && !IsAminoBackbone(hnextj->src->refno) )
  		    hnextj = hnextj->hnext;
              }
          chain = chain->cnext;
  	if( chain )
  	    nextj = chain->glist;
--- 2701,2712 ----
  	            nextj = nextj->gnext;
  		} while( nextj );
  
! 	    } else if( IsNucleo(chain->glist->refno) ) {
! 		while( hnextj && !IsAminoBackbone(hnextj->src->refno) ) {
  		    hnextj = hnextj->hnext;
              }
+             }
+         }
          chain = chain->cnext;
  	if( chain )
  	    nextj = chain->glist;
***************
*** 2603,2612 ****
      if( Database )
      {   ReclaimHBonds( Database->slist );
  	ReclaimHBonds( Database->hlist );
! 	ReclaimBonds( Database->blist );
  
  	while( Database->clist )
! 	{   ReclaimBonds(Database->clist->blist);
  	    gptr = Database->clist->glist;
  	    if( gptr )
  	    {   ReclaimAtoms(gptr->alist);
--- 3064,3074 ----
      if( Database )
      {   ReclaimHBonds( Database->slist );
  	ReclaimHBonds( Database->hlist );
! 	ReclaimBonds( Database );
! 	ReclaimSurfBonds( Database );
  
  	while( Database->clist )
! 	{   ReclaimChainBonds(Database->clist);
  	    gptr = Database->clist->glist;
  	    if( gptr )
  	    {   ReclaimAtoms(gptr->alist);
***************
*** 2673,2678 ****
--- 3135,3141 ----
  void InitialiseDatabase( void )
  {
      FreeMolecule = (void __far*)0;
+     FreeSurfBond = (void __far*)0;
      FreeHBond = (void __far*)0;
      FreeChain = (void __far*)0;
      FreeGroup = (void __far*)0;
*** molecule.h	2004/05/07 19:46:16	1.1
--- molecule.h	2005/01/16 20:25:16
***************
*** 155,167 ****
  #define WideKnotFlag    0x0e
  
  /* Atom Flags */
! #define SphereFlag      0x02     /* Sphere representation */
! #define HeteroFlag      0x04     /* HETATM record         */
! #define HydrogenFlag    0x08     /* Hydrogen atom         */
  #define NormAtomFlag    0x10
  #define NonBondFlag     0x20
! #define BreakFlag       0x40     /* Break in backbone     */
! #define StarFlag        0x80     /* Star representation   */
  
  /* Bond Flags */
  #define WireFlag        0x02     /* Depth-cued wireframe         */
--- 158,174 ----
  #define WideKnotFlag    0x0e
  
  /* Atom Flags */
! #define SphereFlag      0x02     /* Sphere representation         */
! #define HeteroFlag      0x04     /* HETATM record                 */
! #define HydrogenFlag    0x08     /* Hydrogen atom                 */
  #define NormAtomFlag    0x10
  #define NonBondFlag     0x20
! #define BreakFlag       0x40     /* Break in backbone              */
! #define StarFlag        0x80     /* Star representation            */
! #define TouchFlag       0x100    /* Touch by probe                 */
! #define ExpandFlag      0x200    /* Expand by probe radius         */
! #define SurfBondFlag    0x400    /* Atom is part of a surface bond */
! 
  
  /* Bond Flags */
  #define WireFlag        0x02     /* Depth-cued wireframe         */
***************
*** 215,221 ****
          void   *label;                    /* Atom Label Structure  */
          Byte   elemno;                    /* Atomic Number         */
          int    refno;                     /* ElemDesc index number */
!         Byte   flag;                      /* Database flags        */
          char   altl;                      /* Alternate Location    */
          short  irad;                      /* Image Radius          */
          short  mbox;                      /* Shadow Casting NOnce  */
--- 222,228 ----
          void   *label;                    /* Atom Label Structure  */
          Byte   elemno;                    /* Atomic Number         */
          int    refno;                     /* ElemDesc index number */
!         short  flag;                      /* Database flags        */
          char   altl;                      /* Alternate Location    */
          short  irad;                      /* Image Radius          */
          short  mbox;                      /* Shadow Casting NOnce  */
***************
*** 223,228 ****
--- 230,236 ----
          short  visited;                   /* For bond rotation     */
          short  nbonds;                    /* For bond rotation     */ 
          struct _Atom __far *bonds[MaxBonds];
+         void   *surfbonds;                /* Surface bonds list    */
      } RAtom;
  
  
***************
*** 235,244 ****
          short aradius;                   /* World Alt Radius      */
          short iarad;                     /* Image Alt Radius      */
          short col;                       /* Bond Colour           */
!         Byte  flag;                      /* Database flags        */
          char  altl;                      /* Bond Alternate Loc    */
      } Bond;
  
  typedef struct _Group {
          struct _Group __far *gnext;       /* Linked list of groups */
          RAtom __far *alist;                /* Linked list of atoms  */
--- 243,267 ----
          short aradius;                   /* World Alt Radius      */
          short iarad;                     /* Image Alt Radius      */
          short col;                       /* Bond Colour           */
!         short flag;                      /* Database flags        */
          char  altl;                      /* Bond Alternate Loc    */
      } Bond;
  
+ typedef struct _SurfBond {
+         struct _SurfBond __far *sbnext;   /* Linked list of bonds  */
+         RAtom  __far *srcatom;            /* Source Atom Ptr       */
+         RAtom  __far *dstatom;            /* Destination Atom Ptr  */
+         Long   sxyz;                      /* Bond length           */
+         Long   wp;                        /* Torus waist           */
+         Long   w1,w2;                     /* Torus throats         */
+         Long   u1,u2;                     /* Probe offsets         */
+         Long   t1,t2;                     /* Torus offsets         */
+         short  col;                       /* Bond Colour           */
+         short  flag;                      /* Database flags        */
+         char   altl;                      /* Bond Alternate Loc    */
+     } SurfBond;
+ 
+ 
  typedef struct _Group {
          struct _Group __far *gnext;       /* Linked list of groups */
          RAtom __far *alist;                /* Linked list of atoms  */
***************
*** 251,257 ****
          char  sinsert;                    /* Secondary insert code */
          Byte  refno;                      /* Residue index number  */
          Byte  struc;                      /* Secondary Structure   */
!         Byte  flag;                       /* Database flags        */
          short model;                      /* Group Model Number    */
      } Group;
   
--- 274,280 ----
          char  sinsert;                    /* Secondary insert code */
          Byte  refno;                      /* Residue index number  */
          Byte  struc;                      /* Secondary Structure   */
!         short flag;                       /* Database flags        */
          short model;                      /* Group Model Number    */
      } Group;
   
***************
*** 286,292 ****
          short aradius;                    /* World Alt Radius      */
          short iarad;                      /* Image Alt Radius      */
          Char offset;                      /* Signed Offset            */
!         Byte flag;                        /* Database flags           */
          Byte col;                         /* Hydrogen bond colour     */
          char altl;                        /* Bond Alternate Loc       */
      } HBond;
--- 309,315 ----
          short aradius;                    /* World Alt Radius      */
          short iarad;                      /* Image Alt Radius      */
          Char offset;                      /* Signed Offset            */
!         short flag;                       /* Database flags           */
          Byte col;                         /* Hydrogen bond colour     */
          char altl;                        /* Bond Alternate Loc       */
      } HBond;
***************
*** 296,301 ****
--- 319,325 ----
          HBond __far *hlist;               /* Linked list of hbonds    */
          Chain __far *clist;               /* Linked list of chains    */
          Bond __far *blist;                /* Linked list of bonds     */
+         SurfBond __far *sblist;           /* Linked list of surf bonds*/
      } Molecule;
  
  
***************
*** 345,350 ****
--- 369,375 ----
          double cell[6];
  
          Long bondcount;
+         Long srfbondcount;
          int chaincount;
          int ssbondcount;
          int hbondcount;
***************
*** 483,488 ****
--- 508,514 ----
  
  int HBondChainsFlag;
  
+ SurfBond __far *FreeSurfBond;
  HBond __far *FreeHBond;
  Bond __far *FreeBond;
  Bond __far *NewBond;
***************
*** 529,534 ****
--- 555,561 ----
  
  extern int HBondChainsFlag;
  
+ extern SurfBond __far *FreeSurfBond;
  extern HBond __far *FreeHBond;
  extern Bond __far *FreeBond;
  extern Bond __far *NewBond;
***************
*** 558,563 ****
--- 585,591 ----
  void CreateBondOrder( Long, Long );
  void CreateNewBond( Long, Long );
  void CreateMoleculeBonds( int, int, int );
+ void CreateSurfaceBonds( void );
  RAtom __far *FindCysSulphur( Group __far *group );
  void FindDisulphideBridges( void );
  void TestDisulphideBridge( Group __far *, Group __far *, RAtom __far * );
*** mswin31.c	2005/01/16 20:12:09	1.2
--- mswin31.c	2005/01/16 20:25:17
***************
*** 410,415 ****
--- 416,422 ----
    ModifyMenu(hMenu,IDM_RIBBONS,  MF_STRING,IDM_RIBBONS,  MsgStrs[StrMRibbons]);
    ModifyMenu(hMenu,IDM_STRANDS,  MF_STRING,IDM_STRANDS,  MsgStrs[StrMStrands]);
    ModifyMenu(hMenu,IDM_CARTOONS, MF_STRING,IDM_CARTOONS, MsgStrs[StrMCartoon]);
+   ModifyMenu(hMenu,IDM_MOLSURF,  MF_STRING,IDM_MOLSURF,  MsgStrs[StrMMolSurf]);
  
    ModifyMenu(hMenu,IDM_MONO,     MF_STRING,IDM_MONO,     MsgStrs[StrMMonochr]);
    ModifyMenu(hMenu,IDM_CPK,      MF_STRING,IDM_CPK,      MsgStrs[StrMCPK]);
*** multiple.c	2004/05/07 19:46:16	1.1
--- multiple.c	2005/01/16 20:25:17
***************
*** 218,340 ****
  
     /* graphics.h */
      
!     { DialValue,          sizeof (DialValue),      0},
  
      /* molecule.h */
!     { &Info,              sizeof (Info),           0},
!     { &MainGroupCount,    sizeof (MainGroupCount), 0},
!     { &HetaGroupCount,    sizeof (HetaGroupCount), 0},
!     { &MainAtomCount,     sizeof (MainAtomCount),  0},
!     { &HetaAtomCount,     sizeof (HetaAtomCount),  0},
!     { &CisBondCutOff,     sizeof (CisBondCutOff),  0},
!     { &MinX,              sizeof (MinX),           0},
!     { &MinY,              sizeof (MinY),           0},
!     { &MinZ,              sizeof (MinZ),           0},
!     { &MaxX,              sizeof (MaxX),           0},
!     { &MaxY,              sizeof (MaxY),           0},
!     { &MaxZ,              sizeof (MaxZ),           0},
!     { &HMinMaxFlag,       sizeof (HMinMaxFlag),    0},
!     { &MMinMaxFlag,       sizeof (MMinMaxFlag),    0},
!     { &MinMainTemp,       sizeof (MinMainTemp),    0},
!     { &MaxMainTemp,       sizeof (MaxMainTemp),    0},
!     { &MinHetaTemp,       sizeof (MinHetaTemp),    0},
!     { &MaxHetaTemp,       sizeof (MaxHetaTemp),    0},
!     { &MinMainRes,        sizeof (MinMainRes),     0},
!     { &MaxMainRes,        sizeof (MaxMainRes),     0},
!     { &MinHetaRes,        sizeof (MinHetaRes),     0},
!     { &MaxHetaRes,        sizeof (MaxHetaRes),     0},
!     { &MinAltl,           sizeof (MinAltl),        0},
!     { &MaxAltl,           sizeof (MaxAltl),        0},
!     { &CurMolecule,       sizeof (CurMolecule),    0},
!     { &CurChain,          sizeof (CurChain),       0},
!     { &CurGroup,          sizeof (CurGroup),       0},
!     { &CurAtom,           sizeof (CurAtom),        0},
!     { &IntList,           sizeof (IntList),        0},
!     { &Database,          sizeof (Database),       0},
!     { UserMask,           sizeof (UserMask),       0},
!     { &MinHBondDist,      sizeof (MinHBondDist),   0},
!     { &MaxHBondDist,      sizeof (MaxHBondDist),   0},
!     { &MinBondDist,       sizeof (MinBondDist),    0},
!     { &MaxBondDist,       sizeof (MaxBondDist),    0},
!     { &ElemNo,            sizeof (ElemNo),         0},
!     { &ResNo,             sizeof (ResNo),          0},
!     { &HasHydrogen,       sizeof (HasHydrogen),    0},
!     { &MaskCount,         sizeof (MaskCount),      0},
!     { &NMRModel,          sizeof (NMRModel),       0},
!     { &NullBonds,         sizeof (NullBonds),      0},
!     { &MarkAtoms,         sizeof (MarkAtoms),      0},
!     { &HBondChainsFlag,   sizeof (HBondChainsFlag), 0},
  
      /* render.h */
!     { &VoxelsClean,       sizeof (VoxelsClean),    0},
  
      /* repres.h */
!     { &DotPtr,            sizeof (DotPtr),         0},
  
      /* command.h */
  
!     { &SelectCount,       sizeof (SelectCount),    0},
       
      /* transfor.h */
!     { &LastRX,            sizeof (LastRX),         0},
!     { &LastRY,            sizeof (LastRY),         0},
!     { &LastRZ,            sizeof (LastRZ),         0},
!     { &LastTX,            sizeof (LastTX),         0},
!     { &LastTY,            sizeof (LastTY),         0},
!     { &LastTZ,            sizeof (LastTZ),         0},
!     { &CenX,              sizeof (CenX),           0},
!     { &CenY,              sizeof (CenY),           0},
!     { &CenZ,              sizeof (CenZ),           0},
!     { &ShiftS,            sizeof (ShiftS),         0},
!     { &XlateCen,          sizeof (XlateCen),       0},
!     { &OrigCX,            sizeof (OrigCX),         0},
!     { &OrigCY,            sizeof (OrigCY),         0},
!     { &OrigCZ,            sizeof (OrigCZ),         0},
!     { RotX,               sizeof (RotX),           0},
!     { RotY,               sizeof (RotY),           0},
!     { RotZ,               sizeof (RotZ),           0},
!     { LRotX,              sizeof (LRotX),          0},
!     { LRotY,              sizeof (LRotY),          0},
!     { LRotZ,              sizeof (LRotZ),          0},
!     { LOffset,            sizeof (LOffset),        0},
!     { MatX,               sizeof (MatX),           0},
!     { MatY,               sizeof (MatY),           0},
!     { MatZ,               sizeof (MatZ),           0},
!     { InvX,               sizeof (InvX),           0},
!     { InvY,               sizeof (InvY),           0},
!     { InvZ,               sizeof (InvZ),           0},
!     { &Zoom,              sizeof (Zoom),           0},
!     { &Scale,             sizeof (Scale),          0},
!     { &IScale,            sizeof (IScale),         0},
!      
!     { &XOffset,           sizeof (XOffset),        0},
!     { &YOffset,           sizeof (YOffset),        0},
!     { &ZOffset,           sizeof (ZOffset),        0},
       
      /* transfor.h */
!     { &UseScreenClip,     sizeof (UseScreenClip),  0},
!     { &DrawAtoms,         sizeof (DrawAtoms),      0},
!     { &DrawBonds,         sizeof (DrawBonds),      0},
!     { &DrawRibbon,        sizeof (DrawRibbon),     0},
!     { &LocalRadius,       sizeof (LocalRadius),  0},
!     { &MaxAtomRadius,     sizeof (MaxAtomRadius),  0},
!     { &MaxBondRadius,     sizeof (MaxBondRadius),  0},
!     { &ZoneBoth,          sizeof (ZoneBoth),       0},
  
      /* bond rotation stuff */
!     { &BRotValue, sizeof (BRotValue), 0},
!     { &BLastRot, sizeof (BLastRot), 0},
!     { BAxis, sizeof (BAxis), 0},
!     { &BSrcAtom, sizeof (BSrcAtom), 0},
!     { &BDstAtom, sizeof (BDstAtom), 0},
!     { &BondSelected, sizeof (BondSelected), 0},
!     { &BondsSelected, sizeof (BondsSelected), 0},
       
  #ifdef MOVIE_DONE
      /* script.c movie stuff */
!     { NewDialValue   ,    sizeof (NewDialValue), 0},
!     { &firstCmd, sizeof (firstCmd), 0},
!     { LastDialValue  ,    sizeof (LastDialValue), 0},
  #endif
       
      { NULL, 0, 0}
--- 221,347 ----
  
     /* graphics.h */
      
!     { DialValue,          sizeof (DialValue),      0 },
  
      /* molecule.h */
!     { &Info,              sizeof (Info),           0 },
!     { &MainGroupCount,    sizeof (MainGroupCount), 0 },
!     { &HetaGroupCount,    sizeof (HetaGroupCount), 0 },
!     { &MainAtomCount,     sizeof (MainAtomCount),  0 },
!     { &HetaAtomCount,     sizeof (HetaAtomCount),  0 },
!     { &CisBondCutOff,     sizeof (CisBondCutOff),  0 },
!     { &MinX,              sizeof (MinX),           0 },
!     { &MinY,              sizeof (MinY),           0 },
!     { &MinZ,              sizeof (MinZ),           0 },
!     { &MaxX,              sizeof (MaxX),           0 },
!     { &MaxY,              sizeof (MaxY),           0 },
!     { &MaxZ,              sizeof (MaxZ),           0 },
!     { &HMinMaxFlag,       sizeof (HMinMaxFlag),    0 },
!     { &MMinMaxFlag,       sizeof (MMinMaxFlag),    0 },
!     { &MinMainTemp,       sizeof (MinMainTemp),    0 },
!     { &MaxMainTemp,       sizeof (MaxMainTemp),    0 },
!     { &MinHetaTemp,       sizeof (MinHetaTemp),    0 },
!     { &MaxHetaTemp,       sizeof (MaxHetaTemp),    0 },
!     { &MinMainRes,        sizeof (MinMainRes),     0 },
!     { &MaxMainRes,        sizeof (MaxMainRes),     0 },
!     { &MinHetaRes,        sizeof (MinHetaRes),     0 },
!     { &MaxHetaRes,        sizeof (MaxHetaRes),     0 },
!     { &MinAltl,           sizeof (MinAltl),        0 },
!     { &MaxAltl,           sizeof (MaxAltl),        0 },
!     { &CurMolecule,       sizeof (CurMolecule),    0 },
!     { &CurChain,          sizeof (CurChain),       0 },
!     { &CurGroup,          sizeof (CurGroup),       0 },
!     { &CurAtom,           sizeof (CurAtom),        0 },
!     { &IntList,           sizeof (IntList),        0 },
!     { &Database,          sizeof (Database),       0 },
!     { UserMask,           sizeof (UserMask),       0 },
!     { &MinHBondDist,      sizeof (MinHBondDist),   0 },
!     { &MaxHBondDist,      sizeof (MaxHBondDist),   0 },
!     { &MinBondDist,       sizeof (MinBondDist),    0 },
!     { &MaxBondDist,       sizeof (MaxBondDist),    0 },
!     { &ElemNo,            sizeof (ElemNo),         0 },
!     { &ResNo,             sizeof (ResNo),          0 },
!     { &HasHydrogen,       sizeof (HasHydrogen),    0 },
!     { &MaskCount,         sizeof (MaskCount),      0 },
!     { &NMRModel,          sizeof (NMRModel),       0 },
!     { &NullBonds,         sizeof (NullBonds),      0 },
!     { &MarkAtoms,         sizeof (MarkAtoms),      0 },
!     { &HBondChainsFlag,   sizeof (HBondChainsFlag), 0 },
  
      /* render.h */
!     { &VoxelsClean,       sizeof (VoxelsClean),    0 },
  
      /* repres.h */
!     { &DotPtr,            sizeof (DotPtr),         0 },
!     { &ProbeRadius,       sizeof (ProbeRadius),    0 },
!     { &iProbeRad,         sizeof (iProbeRad),      0 },
! 
  
      /* command.h */
  
!     { &SelectCount,       sizeof (SelectCount),    0 },
       
      /* transfor.h */
!     { &LastRX,            sizeof (LastRX),         0 },
!     { &LastRY,            sizeof (LastRY),         0 },
!     { &LastRZ,            sizeof (LastRZ),         0 },
!     { &LastTX,            sizeof (LastTX),         0 },
!     { &LastTY,            sizeof (LastTY),         0 },
!     { &LastTZ,            sizeof (LastTZ),         0 },
!     { &CenX,              sizeof (CenX),           0 },
!     { &CenY,              sizeof (CenY),           0 },
!     { &CenZ,              sizeof (CenZ),           0 },
!     { &ShiftS,            sizeof (ShiftS),         0 },
!     { &XlateCen,          sizeof (XlateCen),       0 },
!     { &OrigCX,            sizeof (OrigCX),         0 },
!     { &OrigCY,            sizeof (OrigCY),         0 },
!     { &OrigCZ,            sizeof (OrigCZ),         0 },
!     { RotX,               sizeof (RotX),           0 },
!     { RotY,               sizeof (RotY),           0 },
!     { RotZ,               sizeof (RotZ),           0 },
!     { LRotX,              sizeof (LRotX),          0 },
!     { LRotY,              sizeof (LRotY),          0 },
!     { LRotZ,              sizeof (LRotZ),          0 },
!     { LOffset,            sizeof (LOffset),        0 },
!     { MatX,               sizeof (MatX),           0 },
!     { MatY,               sizeof (MatY),           0 },
!     { MatZ,               sizeof (MatZ),           0 },
!     { InvX,               sizeof (InvX),           0 },
!     { InvY,               sizeof (InvY),           0 },
!     { InvZ,               sizeof (InvZ),           0 },
!     { &Zoom,              sizeof (Zoom),           0 },
!     { &Scale,             sizeof (Scale),          0 },
!     { &IScale,            sizeof (IScale),         0 },
!      
!     { &XOffset,           sizeof (XOffset),        0 },
!     { &YOffset,           sizeof (YOffset),        0 },
!     { &ZOffset,           sizeof (ZOffset),        0 },
       
      /* transfor.h */
!     { &UseScreenClip,     sizeof (UseScreenClip),  0 },
!     { &DrawAtoms,         sizeof (DrawAtoms),      0 },
!     { &DrawSurf,          sizeof (DrawSurf),       0 },
!     { &DrawBonds,         sizeof (DrawBonds),      0 },
!     { &DrawRibbon,        sizeof (DrawRibbon),     0 },
!     { &LocalRadius,       sizeof (LocalRadius),    0 },
!     { &MaxAtomRadius,     sizeof (MaxAtomRadius),  0 },
!     { &MaxBondRadius,     sizeof (MaxBondRadius),  0 },
!     { &ZoneBoth,          sizeof (ZoneBoth),       0 },
  
      /* bond rotation stuff */
!     { &BRotValue, sizeof (BRotValue), 0 },
!     { &BLastRot, sizeof (BLastRot), 0 },
!     { BAxis, sizeof (BAxis), 0 },
!     { &BSrcAtom, sizeof (BSrcAtom), 0 },
!     { &BDstAtom, sizeof (BDstAtom), 0 },
!     { &BondSelected, sizeof (BondSelected), 0 },
!     { &BondsSelected, sizeof (BondsSelected), 0 },
       
  #ifdef MOVIE_DONE
      /* script.c movie stuff */
!     { NewDialValue   ,    sizeof (NewDialValue), 0 },
!     { &firstCmd, sizeof (firstCmd), 0 },
!     { LastDialValue  ,    sizeof (LastDialValue), 0 },
  #endif
       
      { NULL, 0, 0}
*** pixutils.c	2004/05/07 19:46:16	1.1
--- pixutils.c	2005/01/16 20:25:17
***************
*** 133,144 ****
  #include "repres.h"
  #include "render.h"
  #include "font.h"
! 
! #ifdef INVERT
! #define InvertY(y) (y)
! #else
! #define InvertY(y) (-(y))
! #endif
  
  /* Sutherland-Cohen Line Clipping Macros */
  #define BitAbove    0x01
--- 157,163 ----
  #include "repres.h"
  #include "render.h"
  #include "font.h"
! #include "langsel.h"
  
  /* Sutherland-Cohen Line Clipping Macros */
  #define BitAbove    0x01
***************
*** 150,160 ****
  
  #define Reject(x,y)   ((x)&(y))
  #define Accept(x,y)   (!((x)|(y)))
- #define RootSix       2.44948974278
- 
- /* These define light source position */
- #define LightDot(x,y,z)  ((x)+InvertY(y)+(z)+(z))
- #define LightLength      RootSix
  
  
  typedef struct {
--- 169,174 ----
***************
*** 170,182 ****
  
  
  /* Note: DrawCylinderCaps currently employs an
!  *       extremely crude hack to avoid stripes
!  *       appearing along cylinders.
   */
! #define ARCSIZE  2048
  
  static ArcEntry __far *ArcAcPtr;
  static ArcEntry __far *ArcDnPtr;
  #if defined(IBMPC) || defined(APPLEMAC)
  static ArcEntry __far *ArcAc;
  static ArcEntry __far *ArcDn;
--- 184,199 ----
  
  
  /* Note: DrawCylinderCaps currently employs an
! *      extremely crude hack to avoid stripes
! *      appearing along cylinders.
   */
! #define ARCSIZE  4096
  
  static ArcEntry __far *ArcAcPtr;
  static ArcEntry __far *ArcDnPtr;
+ static ArcEntry __far *OCircle;
+ static ArcEntry __far *NCircle;
+ static ArcEntry __far *TCircle;
  #if defined(IBMPC) || defined(APPLEMAC)
  static ArcEntry __far *ArcAc;
  static ArcEntry __far *ArcDn;
***************
*** 184,204 ****
  static ArcEntry ArcAc[ARCSIZE];
  static ArcEntry ArcDn[ARCSIZE];
  #endif
  
  static char FontDimen[23];
  static int FontWid[97];
  static int ClipStatus;
  
  
  
! #define SETPIXEL(dptr,fptr,d,c)    if( (d) > *(dptr) )              \
!                                    {   *(dptr) = (d);               \
!                                        *(fptr) = (c);               \
                                     }
! #define SETPIXELP(dptr,fptr,d,c,ca,p) if( (d) > *(dptr))            \
!                                    {   *(dptr) = (d);               \
!                                        if(!p) {*(fptr) = (c); }      \
!                                        else  {*(fptr) = (ca);}      \
                                     }
  
  #define OutCode(res,x,y,z)            \
--- 201,241 ----
  static ArcEntry ArcAc[ARCSIZE];
  static ArcEntry ArcDn[ARCSIZE];
  #endif
+ static int OR, NR, ODots, NDots;
+ static Long C[3], A[3];
+ static Long Cprev[3], Cnext[3];
+ 
+ static int radprev, radnext, rad, rada, c;
+ 
  
  static char FontDimen[23];
  static int FontWid[97];
  static int ClipStatus;
  
+ /*
+     The following two macros add a pixel to the z-buffer
+ 
+     dptr-- a pointer to an array of depths
+     fptr-- a pointer to an array of pixels
+     View.shift a- on offset into the arrays
+     d   -- the depth of the new pixel
+     c   -- the color of the new pixel
+     ca  -- an alternate color to use if p is true
  
+     note that increasing z values are closer to the viewer
  
!  */
! 
! 
! 
! #define SETPIXEL(dptr,fptr,d,c)    if( (d) > *((dptr)+View.shift) )  \
!                                    {   *((dptr)+View.shift) = (d);  \
!                                        *((fptr)+View.shift) = (c);   \
                                     }
! #define SETPIXELP(dptr,fptr,d,c,ca,p) if( (d) > *((dptr)+View.shift))   \
!                                    {   *(dptr+View.shift) = (d);               \
!                                        if(!p) {*((fptr)+View.shift) = (c); }   \
!                                        else  {*((fptr)+View.shift) = (ca);}   \
                                     }
  
  #define OutCode(res,x,y,z)            \
***************
*** 273,281 ****
      /* SETPIXEL(dptr,fptr,z,Lut[col]); */
  
      offset = (Long)y*View.yskip+x;
!     dptr = View.dbuf+offset;
!     if( z > *dptr )
!     {   fptr = View.fbuf+offset;
          *fptr = Lut[col];
          *dptr = z;
      }
--- 310,318 ----
      /* SETPIXEL(dptr,fptr,z,Lut[col]); */
  
      offset = (Long)y*View.yskip+x;
!     dptr = View.dbuf+offset+View.shift;
!     if( OValid(offset) && z > *dptr )
!     {   fptr = View.fbuf+offset+View.shift;
          *fptr = Lut[col];
          *dptr = z;
      }
***************
*** 291,299 ****
      if( XValid(x) && YValid(y) && ZValid(z) && ZBack(z) )
      {   /* PlotPoint(x,y,z,col); */
          offset = (Long)y*View.yskip+x;
!         dptr = View.dbuf+offset;
!         if( z > *dptr )
!         {   fptr = View.fbuf+offset;
              *fptr = Lut[col];
              *dptr = z;
          }
--- 328,336 ----
      if( XValid(x) && YValid(y) && ZValid(z) && ZBack(z) )
      {   /* PlotPoint(x,y,z,col); */
          offset = (Long)y*View.yskip+x;
!         dptr = View.dbuf+offset+View.shift;
!         if( OValid(offset) && z > *dptr )
!         {   fptr = View.fbuf+offset+View.shift;
              *fptr = Lut[col];
              *dptr = z;
          }
***************
*** 309,318 ****
      register int inten;
  
      offset = (Long)y*View.yskip+x;
!     dptr = View.dbuf+offset;
  
!     if( z > *dptr )
!     {  fptr = View.fbuf+offset;
         inten = (ColourDepth*(z+ImageRadius-ZOffset))/ImageSize;
         if( inten > 0 )
         {   *fptr = Lut[col+(inten&ColourMask)];
--- 346,355 ----
      register int inten;
  
      offset = (Long)y*View.yskip+x;
!     dptr = View.dbuf+offset+View.shift;
  
!     if( OValid(offset) && z > *dptr )
!     {  fptr = View.fbuf+offset+View.shift;
         inten = (ColourDepth*(z+ImageRadius-ZOffset))/ImageSize;
         if( inten > 0 )
         {   *fptr = Lut[col+(inten&ColourMask)];
***************
*** 332,341 ****
      if( XValid(x) && YValid(y) && ZValid(z) && ZBack(z) )
      {   /* PlotDeepPoint(x,y,z,col); */
          offset = (Long)y*View.yskip+x;
!         dptr = View.dbuf+offset;
  
!         if( z > *dptr )
!         {  fptr = View.fbuf+offset;
             inten = (ColourDepth*(z+ImageRadius-ZOffset))/ImageSize;
             *fptr = Lut[col+inten];
             *dptr = z;
--- 369,378 ----
      if( XValid(x) && YValid(y) && ZValid(z) && ZBack(z) )
      {   /* PlotDeepPoint(x,y,z,col); */
          offset = (Long)y*View.yskip+x;
!         dptr = View.dbuf+offset+View.shift;
  
!         if( OValid(offset) && z > *dptr )
!         {  fptr = View.fbuf+offset+View.shift;
             inten = (ColourDepth*(z+ImageRadius-ZOffset))/ImageSize;
             *fptr = Lut[col+inten];
             *dptr = z;
***************
*** 391,397 ****
      fptr = View.fbuf+offset;
      dptr = View.dbuf+offset;
  
!     SETPIXEL(dptr,fptr,z1,c);
  
      dx = x2-x1;  dy = y2-y1; 
      if( !dx && !dy ) return;
--- 428,436 ----
      fptr = View.fbuf+offset;
      dptr = View.dbuf+offset;
  
!     if ( OValid(offset) ) {
!       SETPIXEL(dptr,fptr,z1,c);
!     }
  
      dx = x2-x1;  dy = y2-y1; 
      if( !dx && !dy ) return;
***************
*** 684,689 ****
--- 723,730 ----
  
  
  
+ 
+ 
  /*=============================================*/
  /*  Macros for 3D Bresenhams Vector Algorithm  */
  /*=============================================*/
***************
*** 731,737 ****
      fptr = View.fbuf+offset;
      dptr = View.dbuf+offset;
  
!     SETPIXEL(dptr,fptr,z1,Lut[col1+c1]);
  
      dx = x2 - x1;  dy = y2 - y1;
      dz = z2 - z1;  dc = c2 - c1;
--- 772,784 ----
      fptr = View.fbuf+offset;
      dptr = View.dbuf+offset;
  
!     if ( OValid(offset) ){
!       /* SETPIXEL(dptr,fptr,z1,Lut[col1+c1]); */
!       if ( z1 > *(dptr+View.shift) ) {
!         *(fptr+View.shift) = Lut[col1+c1];
!         *(dptr+View.shift) = z1;
!       }
!     }
  
      dx = x2 - x1;  dy = y2 - y1;
      dz = z2 - z1;  dc = c2 - c1;
***************
*** 1334,1342 ****
  
              dptr = dbase+xmin;
              for( x=xmin; x<xmax; x++ )
!             {   if( (int)(z>>16) > *dptr )
!                 {   fbase[x] = Lut[(int)(inten>>16)];
!                     *dptr = (int)(z>>16);
                  }
                  inten += di;
                  z += dz;
--- 1381,1389 ----
  
              dptr = dbase+xmin;
              for( x=xmin; x<xmax; x++ )
!             {   if( (int)(z>>16) > *(dptr+View.shift) )
!                 {   fbase[x+View.shift] = Lut[(int)(inten>>16)];
!                     *(dptr+View.shift) = (int)(z>>16);
                  }
                  inten += di;
                  z += dz;
***************
*** 1438,1446 ****
  
              dptr = dbase+xmin;
              for( x=xmin; x<xmax; x++ )
!             {   if( (int)(z>>16) > *dptr )
!                 {   fbase[x] = Lut[p->v[0].inten];
!                     *dptr = (int)(z>>16);
                  }
                  z += dz;
                  dptr++;
--- 1485,1493 ----
  
              dptr = dbase+xmin;
              for( x=xmin; x<xmax; x++ )
!             {   if( (int)(z>>16) > *(dptr+View.shift) )
!                 {   fbase[x+View.shift] = Lut[p->v[0].inten];
!                     *(dptr+View.shift) = (int)(z>>16);
                  }
                  z += dz;
                  dptr++;
***************
*** 1611,1618 ****
                  dptr = dbase+xmin;
                  for( x=xmin; x<xmax; x++ )
                  {   if( (int)(z>>16) > *dptr )
!                     {   fbase[x] = Lut[(int)(inten>>16)];
!                         *dptr = (int)(z>>16);
                      }
                      inten += di;
                      z += dz;
--- 1658,1665 ----
                  dptr = dbase+xmin;
                  for( x=xmin; x<xmax; x++ )
                  {   if( (int)(z>>16) > *dptr )
!                     {   fbase[x+View.shift] = Lut[(int)(inten>>16)];
!                         *(dptr+View.shift) = (int)(z>>16);
                      }
                      inten += di;
                      z += dz;
***************
*** 1772,1779 ****
                  dptr = dbase+xmin;
                  for( x=xmin; x<xmax; x++ )
                  {   if( (int)(z>>16) > *dptr )
!                     {   fbase[x] = Lut[p->v[0].inten];
!                         *dptr = (int)(z>>16);
                      }
                      z += dz;
                      dptr++;
--- 1819,1826 ----
                  dptr = dbase+xmin;
                  for( x=xmin; x<xmax; x++ )
                  {   if( (int)(z>>16) > *dptr )
!                     {   fbase[x+View.shift] = Lut[p->v[0].inten];
!                         *(dptr+View.shift) = (int)(z>>16);
                      }
                      z += dz;
                      dptr++;
***************
*** 2019,2036 ****
  
  #define UpdateAcross(dz)    \
          depth = (dz)+z;                    \
!         if( depth > *dptr )                \
!         {   *dptr = depth;                 \
              fptr = fold+dx;                \
              inten = LightDot(dx,dy,dz);    \
              if( inten>0 )                  \
!             {      inten = (int)((inten*ColConst[rad])>>ColBits); \
!                    *fptr = Lut[col+inten]; \
!             } else *fptr = Lut[col];       \
          }                                  \
          dptr++;  dx++;
  
! #define UpdateLine  \
          dx = -wide;                   \
          dptr = dold-wide;             \
          tptr = LookUp[wide]+wide;     \
--- 2066,2083 ----
  
  #define UpdateAcross(dz)    \
          depth = (dz)+z;                    \
!         if( depth > *(dptr+View.shift) )                \
!         {   *(dptr+View.shift) = depth;                 \
              fptr = fold+dx;                \
              inten = LightDot(dx,dy,dz);    \
              if( inten>0 )                  \
!             {      inten = (int)((inten*colconst(rad))>>ColBits); \
!                    *(fptr+View.shift) = Lut[col+inten]; \
!             } else *(fptr+View.shift) = Lut[col];       \
          }                                  \
          dptr++;  dx++;
  
! #define oUpdateLine  \
          dx = -wide;                   \
          dptr = dold-wide;             \
          tptr = LookUp[wide]+wide;     \
***************
*** 2039,2057 ****
          dold += View.yskip;  fold += View.yskip;             \
          dy++;
  
  
  void DrawSphere( int x, int y, int z, int rad, int col )
  {
      register Pixel __huge *fptr, __huge *fold;
      register short __huge *dptr, __huge *dold;
-     register Byte __far *tptr;
  
      register Long offset;
      register int depth,wide,inten;
      register int dx,dy;
  
      /* Avoid Lookup Table Overflow! */
!     if( rad > MAXRAD ) rad = MAXRAD;
  
      offset = (Long)(y-rad)*View.yskip + x;
      fold=View.fbuf+offset;  
--- 2086,2111 ----
          dold += View.yskip;  fold += View.yskip;             \
          dy++;
  
+ #define UpdateLine  \
+         dx = -wide;                   \
+         dptr = dold-wide;             \
+         while( dx<0 ) { UpdateAcross(pythag(wide,-dx));} \
+         do { UpdateAcross(pythag(wide,dx)); } while(dx<=wide); \
+         dold += View.yskip;  fold += View.yskip;             \
+         dy++;
+ 
  
  void DrawSphere( int x, int y, int z, int rad, int col )
  {
      register Pixel __huge *fptr, __huge *fold;
      register short __huge *dptr, __huge *dold;
  
      register Long offset;
      register int depth,wide,inten;
      register int dx,dy;
  
      /* Avoid Lookup Table Overflow! */
!     /* if( rad > MAXRAD ) rad = MAXRAD; */
  
      offset = (Long)(y-rad)*View.yskip + x;
      fold=View.fbuf+offset;  
***************
*** 2059,2075 ****
  
      dy = -rad;
      while( dy<0 ) 
!     {   wide = LookUp[rad][-dy]; 
          UpdateLine; 
      }
  
      do { 
!         wide = LookUp[rad][dy];  
          UpdateLine; 
      } while( dy<=rad );
  }
  
  
  void ClipSphere( int x, int y, int z, int rad, int col )
  {
      register Pixel __huge *fptr, __huge *fold;
--- 2113,2134 ----
  
      dy = -rad;
      while( dy<0 ) 
!     {   wide = pythag(rad,-dy); 
          UpdateLine; 
      }
  
      do { 
!         wide = pythag(rad,dy);  
          UpdateLine; 
      } while( dy<=rad );
  }
  
  
+ #ifndef max
+ #define max(a, b) ((a) < (b) ? (b) : (a))
+ #endif
+ 
+ 
  void ClipSphere( int x, int y, int z, int rad, int col )
  {
      register Pixel __huge *fptr, __huge *fold;
***************
*** 2080,2089 ****
      register int crad,cwide,temp;
      register Long offset;
  
-     /* Avoid Lookup Table Overflow! */
-     if( rad > MAXRAD ) rad = MAXRAD;
- 
-     /* Visibility Tests */
      if( !TestSphere(x,y,z,rad) )
          return;
  
--- 2139,2144 ----
***************
*** 2111,2123 ****
      /* No Slab Plane Clipping */
      if( !(ClipStatus&BitFront) )
      {   while( dy<=lasty )
!         {   wide = LookUp[rad][AbsFun(dy)];
              lastx = MinFun(wide,side);
              dx = - MinFun(wide,x);
              dptr = dold + dx;
  
              while( dx<=lastx )
!             {   dz = LookUp[wide][AbsFun(dx)];
                  UpdateAcross(dz);
              }
              dold += View.yskip;
--- 2166,2178 ----
      /* No Slab Plane Clipping */
      if( !(ClipStatus&BitFront) )
      {   while( dy<=lasty )
!         {   wide = pythag(rad,AbsFun(dy));
              lastx = MinFun(wide,side);
              dx = - MinFun(wide,x);
              dptr = dold + dx;
  
              while( dx<=lastx )
!             {   dz = pythag(wide,AbsFun(dx));
                  UpdateAcross(dz);
              }
              dold += View.yskip;
***************
*** 2128,2134 ****
      }
  
      dz = SlabValue-z;
!     crad = LookUp[rad][AbsFun(dz)];
   
      if( (z>SlabValue) || (SlabMode==SlabSection) )
      {   if( crad<lasty ) lasty = crad;
--- 2183,2189 ----
      }
  
      dz = SlabValue-z;
!     crad = pythag(rad,AbsFun(dz));
   
      if( (z>SlabValue) || (SlabMode==SlabSection) )
      {   if( crad<lasty ) lasty = crad;
***************
*** 2142,2176 ****
  
      while( dy<=lasty )
      {   temp = AbsFun(dy);
!         wide = LookUp[rad][temp];
          lastx = MinFun(wide,side);
          dx = - MinFun(x,wide);
          dptr = dold + dx;
  
          if( temp<=crad )
!         {   cwide = LookUp[crad][temp];
              while( dx<=lastx )
              {   temp = AbsFun(dx);
                  if( temp<=cwide )
                  {    /* Slab Plane Clipping Modes */
                      switch( SlabMode )
                      {   case( SlabFinal ):
!                                 fold[dx] = Lut[col+SlabInten];
!                                 *dptr = SliceValue;
                                  break;
  
                          case( SlabHollow ):
!                                 dz = LookUp[wide][temp];
                                  depth = z - dz;
!                                 if( depth>*dptr )
!                                 {   *dptr = depth;
                                      inten = LightDot(-dx,-dy,dz);
  
                                      if( inten>0 )
!                                     {   inten=(int)( (inten*ColConst[rad])
                                                       >>(ColBits+1));
!                                         fold[dx] = Lut[col+inten];
!                                     } else fold[dx] = Lut[col];
                                  }
                                  break;
  
--- 2197,2232 ----
  
      while( dy<=lasty )
      {   temp = AbsFun(dy);
!         wide = pythag(rad,temp);
          lastx = MinFun(wide,side);
          dx = - MinFun(x,wide);
          dptr = dold + dx;
  
          if( temp<=crad )
!         {   cwide = pythag(crad,temp);
              while( dx<=lastx )
              {   temp = AbsFun(dx);
                  if( temp<=cwide )
                  {    /* Slab Plane Clipping Modes */
                      switch( SlabMode )
                      {   case( SlabFinal ):
!                                 fold[dx+View.shift] = Lut[col+SlabInten];
!                                 *(dptr+View.shift) = SliceValue;
                                  break;
  
                          case( SlabHollow ):
!                                 dz = pythag(wide,temp);
                                  depth = z - dz;
!                                 if( depth>*(dptr+View.shift) )
!                                 {   *(dptr+View.shift) = depth;
                                      inten = LightDot(-dx,-dy,dz);
  
                                      if( inten>0 )
!                                     {   inten=(int)( (inten*colconst(rad))
                                                       >>(ColBits+1));
!                                         fold[dx+View.shift] =
!                                           Lut[col+inten];
!                                     } else fold[dx+View.shift] = Lut[col];
                                  }
                                  break;
  
***************
*** 2178,2192 ****
                          case( SlabClose ):
                                  dz = SlabValue-z;
                                  depth = dx*dx+dy*dy+dz*dz+SliceValue;
!                                 if( (*dptr<SliceValue) || (depth<*dptr) )
!                                 {   fold[dx] = Lut[col+SlabInten];
!                                     *dptr = depth;
                                  }
                                  break;
                      }
                      dptr++;  dx++;
                  } else if( (z<SlabValue) && (SlabMode!=SlabSection) )
!                 {    dz = LookUp[wide][temp];
                       UpdateAcross(dz);
                  } else
                  {   dptr++;  dx++;
--- 2234,2251 ----
                          case( SlabClose ):
                                  dz = SlabValue-z;
                                  depth = dx*dx+dy*dy+dz*dz+SliceValue;
!                                 if( (*(dptr+View.shift)
!                                   <SliceValue) ||
!                                   (depth<*(dptr+View.shift)) )
!                                 {   fold[dx+View.shift] = 
!                                       Lut[col+SlabInten];
!                                     *(dptr+View.shift) = depth;
                                  }
                                  break;
                      }
                      dptr++;  dx++;
                  } else if( (z<SlabValue) && (SlabMode!=SlabSection) )
!                 {    dz = pythag(wide,temp);
                       UpdateAcross(dz);
                  } else
                  {   dptr++;  dx++;
***************
*** 2194,2200 ****
              }
          } else /* Slabless ScanLine */
              while( dx<=lastx )
!             {   dz = LookUp[wide][AbsFun(dx)];
                  UpdateAcross(dz);
              }
  
--- 2253,2259 ----
              }
          } else /* Slabless ScanLine */
              while( dx<=lastx )
!             {   dz =pythag(wide,AbsFun(dx));
                  UpdateAcross(dz);
              }
  
***************
*** 2253,2258 ****
--- 2312,2838 ----
  }
  
  
+ 
+ 
+ 
+ #define xderiv 0
+ #define yderiv 1
+ #define xxderiv 2
+ #define xyderiv 3
+ #define yyderiv 4
+ 
+ #define xsub 0
+ #define ysub 1
+ #define zsub 2
+ 
+ #define sstep 15
+ 
+ 
+ #define YCIRCPIXEL                                             \
+ offset1 = (Long)((C[ysub]+dy)*View.yskip+(C[xsub]+dx));        \
+ offset2 = (Long)((C[ysub]-dy)*View.yskip+(C[xsub]-dx));        \
+ inten = LightDot(dx+C[xsub]-A[xsub],                           \
+                  dy+C[ysub]-A[ysub],                           \
+                  dz+C[zsub]-A[zsub]);                          \
+ if ( inten > 0 ) {                                             \
+     inten = (int)((inten*colconst(rada))>>ColBits);            \
+ } else {                                                       \
+     inten = 0;                                                 \
+ }                                                              \
+ if (inten > ColourMask) inten = ColourMask;                    \
+ if( OValid(offset1) && XValid(C[xsub]+dx) &&                   \
+     YValid(C[ysub]+dy) &&                                      \
+     ZValid(C[zsub]+dz) &&                                      \
+     ZBack(C[zsub]+dz) ){                                       \
+     SETPIXEL(View.dbuf+offset1,                                \
+              View.fbuf+offset1,C[zsub]+dz,Lut[c+inten]);       \
+ }                                                              \
+ inten = LightDot(-dx+C[xsub]-A[xsub],                          \
+                  -dy+C[ysub]-A[ysub],                          \
+                  -dz+C[zsub]-A[zsub]);                         \
+ if ( inten > 0 ) {                                             \
+     inten = (int)((inten*colconst(rada))>>ColBits);            \
+ } else {                                                       \
+     inten = 0;                                                 \
+ }                                                              \
+ if (inten > ColourMask) inten = ColourMask;                    \
+ if( OValid(offset2) && XValid(C[xsub]-dx) &&                   \
+     YValid(C[ysub]-dy) &&                                      \
+     ZValid(C[zsub]-dz) &&                                      \
+     ZBack(C[zsub]-dz) ){                                       \
+     SETPIXEL(View.dbuf+offset2,                                \
+              View.fbuf+offset2,C[zsub]-dz,Lut[c+inten]);       \
+ }
+ 
+ #ifdef __MC68K__
+ #define SMALLER 1
+ #endif
+ 
+ #ifdef SMALLER
+ #define XCIRCPIXEL CircPixel(dx,dy,dz);
+ void CircPixel( Long dx, Long dy, Long dz) {
+     register int inten;
+     register Long offset1, offset2;
+     YCIRCPIXEL
+ }
+ #else
+ #define XCIRCPIXEL YCIRCPIXEL
+ #endif
+ 
+ 
+ #define CIRCPIXEL                                              \
+ if (s == 0 ) { if (NDots < ARCSIZE) {                          \
+    (NCircle[NDots]).dx = dx;                                   \
+    (NCircle[NDots]).dy = dy;                                   \
+    (NCircle[NDots]).dz = dz;                                   \
+    (NCircle[NDots]).inten = brushdir;                          \
+     NDots++;                                                   \
+    /* fprintf(stderr,"dx, dy, dz, brushdir, G, F, Gxup, Gyup, {%ld, %ld, %ld}, %d, %ld, %ld, %ld, %ld\n",    \
+    dx, dy, dz, brushdir, G, F, Gxup, Gyup);                */   \
+ } else {NR = -1;}   }                                          \
+ {XCIRCPIXEL}
+ 
+ #define CIRCDOZ                                                \
+ if (AbsFun(F+SBD.U[SBD.s2]) < AbsFun(F) ) {                    \
+   {CIRCPIXEL}; (*ds2)++; F+=SBD.U[SBD.s2];                     \
+  } else {                                                      \
+   if (AbsFun(F-SBD.U[SBD.s2]) < AbsFun(F) ) {                  \
+     {CIRCPIXEL}; (*ds2)--; F-=SBD.U[SBD.s2];                   \
+   }                                                            \
+ }
+ 
+ 
+ #define CIRCUP                                                 \
+ G += Gyup; Gxup += 2*(SBD.Us0Us1); Gxdown -= 2*(SBD.Us0Us1);   \
+ Gyup += 2*(SBD.Us1Us1_Us2Us2);                                 \
+ Gydown -= 2*(SBD.Us1Us1_Us2Us2);                               \
+ F += SBD.U[SBD.s1]; (*ds1)++;                                  \
+ CIRCDOZ
+ 
+ 
+ #define CIRCDOWN                                               \
+ G += Gydown; Gxup -= 2*(SBD.Us0Us1); Gxdown += 2*(SBD.Us0Us1); \
+ Gyup -= 2*(SBD.Us1Us1_Us2Us2);                                 \
+ Gydown += 2*(SBD.Us1Us1_Us2Us2);                               \
+ F -= SBD.U[SBD.s1]; (*ds1)--;                                  \
+ CIRCDOZ
+ 
+ 
+ #define CIRCRIGHT                                              \
+ G += Gxup; Gxup += 2*( SBD.Us0Us0_Us2Us2 );                    \
+ Gxdown -= 2*(SBD.Us0Us0_Us2Us2);                               \
+ Gyup += 2*((SBD.Us0Us1)); Gydown -= 2*((SBD.Us0Us1));          \
+ F += SBD.U[SBD.s0]; (*ds0)++;                                  \
+ CIRCDOZ
+ 
+ 
+ 
+ 
+ void DrawCircle( void ) {
+ 	Long dx, dy, dz;
+ 	register Long offset1, offset2;
+ 	register Long F, G, FS, s2S, Gxup, Gxdown, Gyup, Gydown;
+ 	register int inten;
+ 	int spandex, s, w;
+ 	int rdir, cdir, ii;
+ 	Long * ds[3];
+ 	register Long *ds0, *ds1, *ds2;
+ 	long Xmin, Ymin, Xmax, Ymax, Xpeak;
+ 	int updown, ifirst;
+ 	register int brush, brushdir;
+ 	double rinc;
+ 	
+ 	
+ 	rdir = (radnext-radprev)==0?0:((radnext-radprev<0)?-1:1);
+ 	cdir = (Cnext[SBD.s2]-Cprev[SBD.s2])==0?0:((Cnext[SBD.s2]-Cprev[SBD.s2]<0)?-1:1);
+ 	
+ 	
+ 	ds[0] = &dx;
+ 	ds[1] = &dy;
+ 	ds[2] = &dz;
+ 	
+ 	C[0] = Cnext[0]; C[1] = Cnext[1]; C[2] = Cnext[2];
+ 	spandex = 1+AbsFun(rdir)+AbsFun(Cnext[SBD.s2]-Cprev[SBD.s2]);
+ 	w = 0;
+ 	ifirst = 0;
+ 	
+ 	ds0 = ds[SBD.s0]; ds1 = ds[SBD.s1]; ds2 = ds[SBD.s2];
+ 	
+ 	do {
+ 	  if (w == 0) {
+ 	    brush = 2*AbsFun(radnext-radprev) + 2 + max(AbsFun(Cnext[SBD.s0]-Cprev[SBD.s0]), AbsFun(Cnext[SBD.s1]-Cprev[SBD.s1])); 
+ 	    rad = radnext>radprev?radnext:radprev;
+ 		w+=AbsFun (rdir);
+ 		if (w == 0) {w++; spandex++;}
+ 	  } else {
+ 	    Long rat;
+ 		
+ 		if (cdir == 0) break;
+ 		brush = 2;
+ 		switch (ifirst) {
+ 		  case 0:  C[SBD.s2] -= cdir;
+ 				if (Cnext[SBD.s0]-Cprev[SBD.s0] == 0) ifirst++;
+ 				break;
+ 		  case 1:  rat = (4096*(Cnext[SBD.s2]-C[SBD.s2]))/(Cnext[SBD.s2]-Cprev[SBD.s2]);
+ 		        C[SBD.s0] = (rat*Cprev[SBD.s0]+(4096-rat)*Cnext[SBD.s0])/4096;
+ 				if (Cnext[SBD.s1]-Cprev[SBD.s1] == 0) ifirst++;
+ 				break;
+ 		  case 2:  rat = (4096*(Cnext[SBD.s2]-C[SBD.s2]))/(Cnext[SBD.s2]-Cprev[SBD.s2]);
+ 		        C[SBD.s1] = (rat*Cprev[SBD.s1]+(4096-rat)*Cnext[SBD.s1])/4096;
+ 		        break;
+ 		}
+ 		
+ 		ifirst++; if (ifirst==3) {w++; ifirst=0;}
+ 	  }
+ 	  if (brush > rad) brush = rad;
+ 	
+ 	
+ 	// now |U[SBD.s0]| <= |U[SBD.s1]| <= |U[SBD.s2]|, draw an s0-s1 curve
+ 		
+ 		rada = (int)(.5+sqrt(
+ 							  (double)(rad*rad+(C[0]-A[0])*(C[0]-A[0])
+ 									   +(C[1]-A[1])*(C[1]-A[1])
+ 									   +(C[2]-A[2])*(C[2]-A[2]))));
+ 	     /*
+ 		 if (OR > 0 && rad <= OR && 2*rad> OR) {
+ 			double rat = ((double)rad)/((double)OR);
+ 			for (ii=0; ii<ODots; ii++) {
+ 				dx = rint(rat*(OCircle[ii]).dx);
+ 				dy = rint(rat*(OCircle[ii]).dy);
+ 				dz = rint(rat*(OCircle[ii]).dz);
+ 				brushdir = OCircle[ii].inten;
+ 				F = dx*SBD.U[0] + dy*SBD.U[1] + dz*SBD.U[2];
+ 				{XCIRCPIXEL}
+ 				for (s = 1; s < brush; s++) {	
+ 					switch (brushdir) 
+ 					{
+ 						case 0:  (*ds0)++; F += SBD.U[SBD.s0]; break;
+ 						case 1:  (*ds0)++; F += SBD.U[SBD.s0]; {CIRCDOZ} {XCIRCPIXEL}; 
+ 						case 2:  (*ds1)--; F -= SBD.U[SBD.s1]; break;
+ 						case 3:  (*ds0)--; F -= SBD.U[SBD.s0]; {CIRCDOZ} {XCIRCPIXEL}; 
+ 								 (*ds1)--; F -= SBD.U[SBD.s1]; break;
+ 						case 4:  (*ds0)--; F -= SBD.U[SBD.s0]; break;
+ 					}
+ 					{CIRCDOZ} {XCIRCPIXEL}
+ 				}
+ 			}
+ 			continue;
+ 		}
+ 		*/
+ 		NDots = 0;
+ 		NR = rad;
+ 		
+ 		Xmin = - (Xmax =
+ 				  (Long)(rint((double)(rad))*(sqrt((double)(SBD.Us1Us1_Us2Us2)))/
+ 						 sqrt((double)(SBD.Us0Us0_Us1Us1_Us2Us2))));
+ 		
+ 		if ( Xmax > rad) {
+ 			Xmin = -(Xmax=rad);
+ 		}
+ 		Ymax = -(Long)(rint((double)(rad*(SBD.Us0Us1)))/
+ 					   ( sqrt((double)(SBD.Us1Us1_Us2Us2))*
+ 						 sqrt((double)(SBD.Us0Us0_Us1Us1_Us2Us2)) ));
+ 		Ymin = -Ymax;
+ 		if ( Ymax > rad ) {
+ 			Ymin = -(Ymax=rad);
+ 		}
+ 		Xpeak = -(Long)(rint((double)(rad*(SBD.Us0Us1)))/
+ 					   ( sqrt((double)(SBD.Us0Us0_Us2Us2))*
+ 						 sqrt((double)(SBD.Us0Us0_Us1Us1_Us2Us2)) ));
+ 		*ds0 = Xmin;
+ 		*ds1 = Ymin;
+ 		
+ 		
+ 		G = Xmin*Xmin*(SBD.Us0Us0_Us2Us2)+Ymin*Ymin*(SBD.Us1Us1_Us2Us2)  +
+ 			2*Xmin*Ymin*(SBD.Us0Us1) - rad*rad*SBD.U[SBD.s2]*SBD.U[SBD.s2];
+ 		Gxup = (2*Xmin+1)*(SBD.Us0Us0_Us2Us2) + 2*Ymin*(SBD.Us0Us1);
+ 		Gyup = (2*Ymin+1)*(SBD.Us1Us1_Us2Us2) + 2*Xmin*(SBD.Us0Us1);
+ 		Gxdown = (-2*Xmin+1)*(SBD.Us0Us0_Us2Us2) - 2*Ymin*(SBD.Us0Us1);
+ 		Gydown = (-2*Ymin+1)*(SBD.Us1Us1_Us2Us2) - 2*Xmin*(SBD.Us0Us1);
+ 		*ds2= (int)(rint(-(double)((*ds0)*SBD.U[SBD.s0]+(*ds1)*SBD.U[SBD.s1]))/((double)SBD.U[SBD.s2]));
+ 		F = dx*SBD.U[0] + dy*SBD.U[1] + dz*SBD.U[2];
+ 		FS = F;
+ 		s2S = *ds2;
+ 		brushdir = 0;
+ 		for (s=0; s< brush; s++) {
+ 		    CIRCPIXEL
+ 			(*ds0)++;
+ 			F += SBD.U[SBD.s0];
+             CIRCDOZ
+ 		}
+ 		(*ds0)-=brush;
+ 		updown = 1;
+ 		F = FS;
+ 		*ds2 = s2S;
+ 		
+ 		/*
+ 		                      Gxup small
+ 		                      Gyup > 0
+ 						     ----------
+ 						   /\  | | | | /\
+ 						  /\1     2    3/\
+ 			Gxup < 0     | ----       ----|  Gxup > 0
+ 		   Gyup small	 | -0-        --4-|  Gydown small
+ 		 
+ 		 
+ 		 */
+ 		
+ 		
+ 		while ((*ds0 < Xmax )|| (*ds0 == Xmax && *ds1 > Ymax)) {  /* Start by going up and right */
+ 			if ( (3*(*ds0) < 2*Xmin + Xpeak) ) { 
+ 				brushdir = 0;
+ 			} else {
+ 			    if ( (3*(*ds0) < Xmin +2*Xpeak) ) {
+ 				brushdir = 1;
+ 				} else {
+ 				  if ( (3*(*ds0) < 2*Xpeak+ Xmax)  ) { 
+ 				  brushdir = 2;
+ 				  } else {
+ 				    if ( (3*(*ds0) < Xpeak + 2*Xmax) ) {
+ 				      brushdir = 3;
+ 					} else {
+ 				      brushdir = 4;
+ 					}
+ 				  }
+ 				} 
+ 		    }
+ 			if (*ds0 < Xpeak) {
+ 			  if ( (AbsFun(G+Gyup) < AbsFun(G+Gxup)) ||
+ 				             (AbsFun(G+Gyup+Gxup+2*(SBD.Us0Us1)) < AbsFun(G+Gxup))) {
+ 				      {CIRCUP}
+ 				      if (AbsFun(G+Gxup) < AbsFun(G) ) {CIRCRIGHT}
+ 				} else {
+ 				{CIRCRIGHT}
+ 				}
+ 			} else {
+ 				if (((AbsFun(G+Gydown) < AbsFun(G+Gxup))  ||
+ 					 (AbsFun(G+Gydown+Gxup-2*(SBD.Us0Us1)) < AbsFun(G+Gxup))     ) || 
+ 					(*ds0 == Xmax && *ds1 > Ymax)){
+ 				{CIRCDOWN}
+ 					if ((AbsFun(G+Gxup) < AbsFun(G)) && *ds0 < Xmax) {CIRCRIGHT}
+ 				} else {
+ 				{CIRCRIGHT}
+ 				}
+ 			}
+ 			FS = F;
+ 			s2S = *ds2;
+             switch(brushdir) {
+ 				/* Starting on the left side of the ellipse */
+ 				case 0: 
+ 					for (s = 0; s < brush; s++) {
+ 					  {CIRCPIXEL}
+ 					  (*ds0)++; F += SBD.U[SBD.s0]; /* go right */
+ 					  {CIRCDOZ}
+ 					}
+ 					(*ds0)-=brush;
+ 					break;
+ 					/* Continue on the upslope of the left side of the ellipse */
+ 				case 1:  
+ 					for (s = 0; s < brush; s++) {
+ 					  {CIRCPIXEL}
+ 					  (*ds0)++; F+= SBD.U[SBD.s0];
+ 					  {CIRCDOZ}
+ 					  if ( s > 0 ){CIRCPIXEL}; 
+ 					  (*ds1)--; F=-SBD.U[SBD.s1]; /* go down right */
+ 					  {CIRCDOZ}
+ 					}
+ 					(*ds0)-=brush; (*ds1)+=brush;
+ 					break;
+ 					/* Continue on the top of the ellipse */
+ 				case 2:  
+ 					for (s = 0; s < brush; s++) {
+ 					  {CIRCPIXEL}
+ 					  (*ds1)--; F-= SBD.U[SBD.s1]; /* go down */
+ 					  {CIRCDOZ}
+ 					}
+ 					(*ds1)+=brush;
+ 					break;
+ 					/* Continue on the down slope of the right of the ellipse */
+ 				case 3:   
+ 					for (s = 0; s < brush; s++) {
+ 					  {CIRCPIXEL}
+ 					  (*ds0)--; F-=SBD.U[SBD.s0];
+ 					  {CIRCDOZ}
+ 					  if ( s > 0 ) {CIRCPIXEL};
+ 					  (*ds1)--; F-=SBD.U[SBD.s1]; /* go down left */
+ 					  {CIRCDOZ}
+ 					}
+ 					(*ds0)+=brush; (*ds1)+=brush;
+ 					break;
+ 					/* Finish on the right side of the ellipse */
+ 				case 4:  
+ 					for (s = 0; s < brush; s++) {
+ 					  {CIRCPIXEL}
+ 					  (*ds0)--; F -= SBD.U[SBD.s0]; /* go right */
+ 					  {CIRCDOZ}
+ 					}
+ 					(*ds0)+=brush;
+ 					break;
+ 			}
+ 			F = FS;
+ 			*ds2 = s2S;
+ 			
+ 		}
+ 		if ( NR > 0 ) {
+ 			TCircle = OCircle;
+ 			OCircle = NCircle;
+ 			NCircle = TCircle;
+ 			OR = rad;
+ 			ODots = NDots;
+ 		}
+         continue;
+ 		} while (w < spandex);
+ }
+ 
+ 
+ void DrawTorus( int x1, int y1, int z1,
+                               int x2, int y2, int z2,
+                               int c1, int c2,
+                               int xrad1, int xrad2, int radp, char altl )
+ {
+ 
+     double ccen;
+     int oClipStatus;
+     
+     register int altc;
+     Long s, smax, t, u;
+     int rad;
+ 
+ 
+     altc=0;
+     if (altl != '\0' && altl != ' ')
+       altc = AltlColours[((int)altl)&(AltlDepth-1)];
+ 
+ 
+     c = c1;
+ 
+     rad = -1;
+     OR = NR = -1;
+     OCircle = ArcAc;
+     NCircle = ArcDn;
+ 	smax = SBD.t1;
+     
+     for (u = SBD.t1; u <= SBD.sxyz-SBD.t2+2*sstep; u+=sstep ) {
+ 	  if ( u < SBD.u1+sstep ) {
+ 	    smax = s = u;
+ 	  } else {
+ 	    s = SBD.sxyz - SBD.t2 + smax+sstep-u;
+         if (s >= SBD.sxyz-SBD.t2 ) {
+             rad = -1;
+             c = c2;
+         }
+ 	  }
+ 
+       if (rad != -1 ) {
+           Cprev[xsub] = Cnext[xsub]; Cprev[ysub] = Cnext[ysub]; Cprev[zsub] = Cnext[zsub];
+       }
+       Cnext[xsub] = ((SBD.sxyz-s)*((Long)SBD.x1)+s*((Long)SBD.x2))/((Long)SBD.sxyz);
+       Cnext[ysub] = ((SBD.sxyz-s)*((Long)SBD.y1)+s*((Long)SBD.y2))/((Long)SBD.sxyz);
+       Cnext[zsub] = ((SBD.sxyz-s)*((Long)SBD.z1)+s*((Long)SBD.z2))/((Long)SBD.sxyz);
+       radnext = (int)(SBD.wp>>4) - pythag(radp,AbsFun((int)((s-SBD.u1)>>4)));
+       if (radnext <0 ) {
+           rad = -1;
+           continue;
+       }
+       if (rad == -1 ) {
+           Cprev[xsub] = Cnext[xsub]; Cprev[ysub] = Cnext[ysub]; Cprev[zsub] = Cnext[zsub];
+       } else {
+           if (Cprev[xsub] == Cnext[xsub] && Cprev[ysub] == Cnext[ysub] && Cprev[zsub] == Cnext[zsub]) continue;
+       }
+       radnext = AbsFun(radnext);
+       if (rad == -1) rad = radnext;
+       radprev = rad;
+       rad = radnext;
+       
+       if (u <= SBD.u1) {
+         ccen = ((double)(SBD.u1-s))/16.;
+         t = SBD.u1 - (Long)rint(((double)(SBD.wp))*ccen/sqrt((double)(radp*radp)-ccen*ccen));
+       } else {
+         ccen = ((double)(SBD.u2-(SBD.sxyz-s)))/16.;
+         t = SBD.u2 - (Long)rint(((double)(SBD.wp))*ccen/sqrt((double)(radp*radp)-ccen*ccen));
+         t = SBD.sxyz - t;
+       }
+       A[xsub] = ((SBD.sxyz-t)*((Long)SBD.x1)+t*((Long)SBD.x2))/((Long)SBD.sxyz);
+       A[ysub] = ((SBD.sxyz-t)*((Long)SBD.y1)+t*((Long)SBD.y2))/((Long)SBD.sxyz);
+       A[zsub] = ((SBD.sxyz-t)*((Long)SBD.z1)+t*((Long)SBD.z2))/((Long)SBD.sxyz);
+ 
+       if (ClipStatus) {
+           oClipStatus = ClipStatus;
+           rada = (int)(.99+sqrt(
+                 (double)(rad*rad+
+                 (Cnext[0]-A[0])*(Cnext[0]-A[0])+
+                 (Cnext[1]-A[1])*(Cnext[1]-A[1])+
+                 (Cnext[2]-A[2])*(Cnext[2]-A[2]))));
+           if (TestSphere(A[0],A[1],A[2],rada)) {
+               if ( (ClipStatus&BitFront) ) {
+                   ClipSphere(A[0],A[1],A[2],rada,c);
+                   rad = -1;
+               } else {
+                   DrawCircle();
+               }
+           }
+           ClipStatus = oClipStatus;
+       } else {
+       DrawCircle();
+       }
+ 
+       if ( altc && s-SBD.u1 < (SBD.sxyz-SBD.t2-SBD.t1)/2 
+                 && SBD.u1-s < (SBD.sxyz-SBD.t2-SBD.t1)/2 ) {
+        c = altc;
+       } else {
+          if (s >= SBD.u1) c = c2;
+       }
+     }
+ 
+ }
+ 
+ 
+ 
+ static int TestSurfaceBond( int x1, int y1, int z1,
+                               int x2, int y2, int z2,
+                               int xrad1, int xrad2, int radp )
+ {
+     ClipStatus = False;
+ 
+     if ( x1+xrad1 < 0 && x2+xrad2 < 0 ) return False;
+     if ( x1-xrad1 >= View.xmax && x2-xrad2 >= View.xmax ) return False;
+ 
+     if ( y1+xrad1 < 0 && y2+xrad2 < 0 ) return False;
+     if ( y1-xrad1 >= View.ymax && y2-xrad2 >= View.ymax ) return False;
+ 
+     if ( UseSlabPlane ) {
+         if ( z1-xrad1 >= SlabValue && z2-xrad1 >= SlabValue ) return False;
+     }
+ 
+     if ( UseDepthPlane ) {
+         if ( z1+xrad1 <= DepthValue && z2+xrad2 <= DepthValue ) return False;
+     }
+ 
+     if ( x1-xrad1 < 0 || x2-xrad2 < 0 ||
+          x1+xrad1 >= View.xmax || x2+xrad2 >= View.xmax ||
+          y1-xrad1 < 0 || y2-xrad2 < 0 ||
+          y1+xrad1 >= View.ymax || y2+xrad2 >= View.ymax ) ClipStatus = True;
+     if ( UseSlabPlane ) {
+         if ( z1+xrad1 > SlabValue || z2+xrad2 > SlabValue) ClipStatus = True;
+     }
+     if ( UseDepthPlane ) {
+         if ( z1-xrad1 < DepthValue || z2-xrad2 > DepthValue) ClipStatus = True;
+     }
+     return True;
+ }
+ 
+ void ClipSurfaceBond( int x1, int y1, int z1,
+                               int x2, int y2, int z2,
+                               int c1, int c2,
+                               int xrad1, int xrad2, int radp, char altl )
+ {
+     if (!TestSurfaceBond(x1,y1,z1,x2,y2,z2,xrad1,xrad2,radp) ) return;
+     /* DrawEllipses( x1,y1,z1, x2,y2,z2,  c1,c2, xrad1,xrad2,radp, altl ); */
+     DrawTorus( x1,y1,z1, x2,y2,z2,  c1,c2, xrad1,xrad2,radp, altl );
+ 
+ }
+ 
+ 
  static void DrawCylinderCaps( int x1, int y1, int z1,
                                int x2, int y2, int z2,
                                int c1, int c2, int rad, char altl )
***************
*** 2291,2310 ****
      fold = View.fbuf+temp;
      dold = View.dbuf+temp;
  
      ArcAcPtr = ArcAc;
      ArcDnPtr = ArcDn;
  
      temp = (Long)-(rad*View.yskip);
      for( dy= -rad; dy<=rad; dy++ )
!     {   wide = LookUp[rad][AbsFun(dy)];
          alts = 0;
  
          for( dx= -wide; dx<=wide; dx++ )
          {   absx = AbsFun(dx);
!             dz = LookUp[wide][absx];
              inten = LightDot(dx,dy,dz);
              if( inten>0 )
!             {   inten = (int)((inten*ColConst[rad])>>ColBits);
              } else inten = 0;
              offset = temp+dx;
  
--- 2871,2893 ----
      fold = View.fbuf+temp;
      dold = View.dbuf+temp;
  
+     if ( rad < 0 ) rad = 0;
+     if ( rad >= MAXRAD ) rad = MAXRAD-1; 
+ 
      ArcAcPtr = ArcAc;
      ArcDnPtr = ArcDn;
  
      temp = (Long)-(rad*View.yskip);
      for( dy= -rad; dy<=rad; dy++ )
!     {   wide =pythag(rad,AbsFun(dy));
          alts = 0;
  
          for( dx= -wide; dx<=wide; dx++ )
          {   absx = AbsFun(dx);
!             dz = pythag(wide,absx);
              inten = LightDot(dx,dy,dz);
              if( inten>0 )
!             {   inten = (int)((inten*colconst(rad))>>ColBits);
              } else inten = 0;
              offset = temp+dx;
  
***************
*** 2328,2353 ****
              k1 = AbsFun(dx+ix); 
              k2 = AbsFun(dx-ix);
  
!             if( ((k1>wide)||(dz>=LookUp[wide][k1]-zrate)) &&
!                 ((k2>wide)||(dz>LookUp[wide][k2]+zrate)) )
  #endif
              {   ArcAcPtr->offset = offset; ArcAcPtr->inten = inten;
                  ArcAcPtr->dx=dx; ArcAcPtr->dy=dy; ArcAcPtr->dz=dz;
                  ArcAcPtr++;
!             }
  
  #ifdef UNUSED
              k1 = AbsFun(dy+iy);
              k2 = AbsFun(dy-iy);
  
!             high = LookUp[rad][absx];
!             if( ((k1>high)||(dz>=LookUp[LookUp[rad][k1]][absx]-zrate)) &&
!                 ((k2>high)||(dz>LookUp[LookUp[rad][k2]][absx]+zrate)) )
  #endif
              {   ArcDnPtr->offset = offset; ArcDnPtr->inten = inten;
                  ArcDnPtr->dx=dx; ArcDnPtr->dy=dy; ArcDnPtr->dz=dz;
                  ArcDnPtr++;
!             }
          }
          temp += View.yskip;
      }
--- 2911,2938 ----
              k1 = AbsFun(dx+ix); 
              k2 = AbsFun(dx-ix);
  
!             if( ((k1>wide)||(dz>=pythag(wide,k1)-zrate)) &&
!                 ((k2>wide)||(dz>pythag(wide,k2)+zrate)) )
  #endif
+             if ( (ArcAcPtr-ArcAc)<ARCSIZE ) {
              {   ArcAcPtr->offset = offset; ArcAcPtr->inten = inten;
                  ArcAcPtr->dx=dx; ArcAcPtr->dy=dy; ArcAcPtr->dz=dz;
                  ArcAcPtr++;
!             } }
  
  #ifdef UNUSED
              k1 = AbsFun(dy+iy);
              k2 = AbsFun(dy-iy);
  
!             high = pythag(rad,absx);
!             if( ((k1>high)||(dz>=pythag(pythag(rad,k1),absx)-zrate)) &&
!                 ((k2>high)||(dz>pythag(pythag(rad,k2),absx)+zrate)) )
  #endif
+             if ( (ArcDnPtr-ArcDn)<ARCSIZE ) {
              {   ArcDnPtr->offset = offset; ArcDnPtr->inten = inten;
                  ArcDnPtr->dx=dx; ArcDnPtr->dy=dy; ArcDnPtr->dz=dz;
                  ArcDnPtr++;
!             } }
          }
          temp += View.yskip;
      }
***************
*** 2562,2573 ****
  
      ptr = ArcAc;
      while( (temp=y+ptr->dy) < 0 )
!         if( ++ptr == ArcAcPtr )
              return;
  
      while( (temp<View.ymax) && (ptr<ArcAcPtr) )
      {   temp = x+ptr->dx;
!         if( XValid(temp) )
          {   dptr = dbase+ptr->offset;  depth = ptr->dz+z;
              SETPIXEL(dptr,fbase+ptr->offset,depth,Lut[ptr->inten+c]);
          }
--- 3147,3158 ----
  
      ptr = ArcAc;
      while( (temp=y+ptr->dy) < 0 )
!         if(++ptr == ArcAcPtr )
              return;
  
      while( (temp<View.ymax) && (ptr<ArcAcPtr) )
      {   temp = x+ptr->dx;
!         if( XValid(temp) && OValid(ptr->offset) )
          {   dptr = dbase+ptr->offset;  depth = ptr->dz+z;
              SETPIXEL(dptr,fbase+ptr->offset,depth,Lut[ptr->inten+c]);
          }
***************
*** 2586,2598 ****
      register int temp;
  
      ptr = ArcDn;
      while( (temp=y+ptr->dy) < 0 )
!         if( ++ptr == ArcDnPtr )
              return;
  
!     while( (temp<View.ymax) && (ptr<ArcDnPtr) )
      {   temp = x+ptr->dx;
!         if( XValid(temp) )
          {   dptr = dbase+ptr->offset;  depth = ptr->dz+z;
              SETPIXEL(dptr,fbase+ptr->offset,depth,Lut[ptr->inten+c]);
          }
--- 3171,3184 ----
      register int temp;
  
      ptr = ArcDn;
+     if (ptr == ArcDnPtr) return;
      while( (temp=y+ptr->dy) < 0 )
!         if(++ptr == ArcDnPtr )
              return;
  
!     while( (temp<View.ymax) && (ptr!=ArcDnPtr) )
      {   temp = x+ptr->dx;
!         if( XValid(temp) && OValid(ptr->offset) )
          {   dptr = dbase+ptr->offset;  depth = ptr->dz+z;
              SETPIXEL(dptr,fbase+ptr->offset,depth,Lut[ptr->inten+c]);
          }
*** pixutils.h	2004/05/07 19:46:16	1.1
--- pixutils.h	2005/01/16 20:25:16
***************
*** 113,123 ****
--- 128,154 ----
  typedef struct {
          Pixel __huge *fbuf;
          short __huge *dbuf;
+         int   __huge *cbuf;
+         int shift;
          int xmax, ymax;
          int yskip;
+         int offmax;
      } ViewStruct;
  
  
+ typedef struct {
+   int rad;
+   Long x1, y1, z1, x2, y2, z2; 
+   Long U[3]; 
+   int  c1, c2;
+   char altl;
+   Long u1, u2, wp, w1, w2, t1, t2;
+   Long sxyz, syz, sxz;
+   Long Us0Us1, Us0Us0_Us1Us1_Us2Us2, Us0Us0_Us2Us2, Us1Us1_Us2Us2;
+   int s0, s1, s2;
+ } SBDstruct;
+ 
+ 
  #define MAXVERT  6
  typedef struct {
          int x, y, z;
***************
*** 133,138 ****
--- 164,189 ----
  #define ZBack(z)      ((!UseDepthPlane) || ((z)>DepthValue))
  #define XValid(x)     (((x)>=0)&&((x)<View.xmax))
  #define YValid(y)     (((y)>=0)&&((y)<View.ymax))
+ #define OValid(o)     (((o)>=0)&&((o)<View.offmax))
+ 
+ #ifdef INVERT
+ #define InvertY(y) (y)
+ #define ProperY(y) (-(y))
+ #else
+ #define InvertY(y) (-(y))
+ #define ProperY(y) (y)
+ #endif
+ 
+ #define RootSix       2.44948974278
+  
+ /* These define light source position */
+ #define LightDot(x,y,z)  ((x)+InvertY(y)+(z)+(z))
+ #define LightLength      RootSix
+ #define LightXComp       1
+ #define LightYComp       1
+ #define LightZComp       2
+ 
+ 
  
  
  #ifdef PIXUTILS
***************
*** 141,146 ****
--- 192,198 ----
  int FontSize;
  int FontPS;
  int FontStroke;
+ SBDstruct SBD;
  
  #else
  extern ViewStruct View;
***************
*** 148,188 ****
  extern int FontSize;
  extern int FontPS;
  extern int FontStroke;
  #endif
  
! void PlotDeepPoint( int, int, int, int );
  void ClipDeepPoint( int, int, int, int );
- 
- void DrawTwinLine( int, int, int, int, int, int, int, int, char );
  void ClipLine( int, int, int, int, int, int, int,  char );
  void ClipTwinLine( int, int, int, int, int, int, int, int, char );
- void ClipDashLine( int, int, int, int, int, int, int, int, char );
- void DrawTwinVector( int, int, int, int, int, int, int, int, char );
- void ClipVector( int, int, int, int, int, int, int, char );
  void ClipTwinVector( int, int, int, int, int, int, int, int, char );
  void ClipDashVector( int, int, int, int, int, int, int, int, char );
- 
- void DrawCylinder( int, int, int, int, int, int, int, int, int, char, int );
- void ClipCylinder( int, int, int, int, int, int, int, int, int, char, int );
- 
- /* void OutLinePolygon( Poly* ); */
- /* void DrawPolygon( Poly* );    */
- /* void ClipPolygon( Poly* );    */
- 
  void DashRibbon( Knot __far*, Knot __far*, int, int );
! void StrandRibbon( Knot __far*, Knot __far*, int, int );
! void SolidRibbon2( Knot __far*, Knot __far*, int, int );
! void SolidRibbon( Knot __far*, Knot __far*, int );
! void RectRibbon( Knot __far*, Knot __far*, int );
  void DrawSphere( int, int, int, int, int );
- void ClipSphere( int, int, int, int, int );
  void DrawStar( int, int, int, int, int );
! void ClipStar( int, int, int, int, int );
! 
! void ClipTwinLine( int, int, int, int, int, int, int, int, char );
! 
  void SetFontSize( int );
  void SetFontStroke( int );
! void DisplayRasString( int, int, int, unsigned char *, int );
! void InitialisePixUtils( void );
! 
--- 200,236 ----
  extern int FontSize;
  extern int FontPS;
  extern int FontStroke;
+ extern SBDstruct SBD;
  #endif
  
! void ClipCylinder( int, int, int, int, int, int, int, int, int, char, int );
! void ClipDashLine( int, int, int, int, int, int, int, int, char );
  void ClipDeepPoint( int, int, int, int );
  void ClipLine( int, int, int, int, int, int, int,  char );
+ void ClipSphere( int, int, int, int, int );
+ void ClipStar( int, int, int, int, int );
+ void ClipSurfaceBond( int, int, int, int, int, int, int, 
+      int, int, int, int, char);
+ void ClipSurfSphere( int, int, int, int, int );
  void ClipTwinLine( int, int, int, int, int, int, int, int, char );
  void ClipTwinVector( int, int, int, int, int, int, int, int, char );
+ void ClipVector( int, int, int, int, int, int, int, char );
  void ClipDashVector( int, int, int, int, int, int, int, int, char );
  void DashRibbon( Knot __far*, Knot __far*, int, int );
! void DisplayRasString( int, int, int, unsigned char *, int );
! void DrawCylinder( int, int, int, int, int, int, int, int, int, char, int );
  void DrawSphere( int, int, int, int, int );
  void DrawStar( int, int, int, int, int );
! void DrawCircle( void );
! void DrawTorus( int, int, int, int, int, int, int, int, int, int, int, char );
! void DrawSurfSphere( int, int, int, int, int );
! void DrawTwinLine( int, int, int, int, int, int, int, int, char );
! void DrawTwinVector( int, int, int, int, int, int, int, int, char );
! void InitialisePixUtils( void );
! void PlotDeepPoint( int, int, int, int );
! void RectRibbon( Knot __far*, Knot __far*, int );
  void SetFontSize( int );
  void SetFontStroke( int );
! void SolidRibbon2( Knot __far*, Knot __far*, int, int );
! void SolidRibbon( Knot __far*, Knot __far*, int );
! void StrandRibbon( Knot __far*, Knot __far*, int, int );
*** rasmac.c	2004/05/07 19:46:16	1.1
--- rasmac.c	2005/01/16 20:25:17
***************
*** 1377,1382 ****
--- 1383,1399 ----
                                        DisableBackbone();
                                        ReDrawFlag |= RFRefresh;
                                        break;
+ 
+                             case(9):  /* Molecular Surface */
+                                       DrawSurf = True;
+                                       ProbeRadius = 350;
+                                       SetVanWaalRadius( SphereFlag | TouchFlag );
+                                       DisableWireframe();
+                                       SetRibbonStatus(False,0,0);
+                                       DisableBackbone();
+                                       CreateSurfaceBonds();
+                                       ReDrawFlag |= RFRefresh;
+                                       break;
                          }
                          break;              
                              
***************
*** 2041,2046 ****
--- 2058,2064 ----
      register long hand;
      register int code;
      WindowPtr win;
+     GrafPtr savePort;
      
      code = FindWindow(ptr->where,&win);
      switch( code )
***************
*** 2053,2065 ****
          case(inSysWindow):  SystemClick(ptr,win);
                              break;
  
!         case(inContent):    if( win == CanvWin )
!                             {   ClickCanvWin( ptr );
                              } else {
!                               if( win == CmndWin )
!                               {   ClickCmndWin( ptr );
                                }
                              }
                              break;
          
          case(inDrag):       if( (win==CanvWin) 
--- 2071,2104 ----
          case(inSysWindow):  SystemClick(ptr,win);
                              break;
  
!         case(inContent):    // Need to recheck that ptr is in the window
!                             GetPort(&savePort);
!                             SetPort(CanvWin);
!                             GlobalToLocal(&ptr->where);
!                             if((win == CmndWin) || ( win == CanvWin && 
!                                ptr->where.h >=0 && ptr->where.h<=XRange &&
!                                ptr->where.v >=0 && ptr->where.v<=YRange)) {
!                               LocalToGlobal(&ptr->where);
!                               SetPort(savePort);
!                               if( win == CanvWin )
!                               {   ClickCanvWin( ptr );
!                               } else {
!                                 if( win == CmndWin )
!                                 {   ClickCmndWin( ptr );
!                                 }
!                               }
!                               break;
                              } else {
!                               if (win == CanvWin &&
!                                   ptr->where.h >=XRange && ptr->where.h<=XRange+24 &&
!                                   ptr->where.v >=YRange && ptr->where.v<=YRange+24) {
!                                   LocalToGlobal(&ptr->where);
!                                   SetPort(savePort);
!                                   GrowCanvWin( ptr->where );
!                                   break;
                                }
                              }
+                             SetPort(savePort);
                              break;
          
          case(inDrag):       if( (win==CanvWin) 
***************
*** 2454,2459 ****
--- 2493,2499 ----
      ReDrawFlag = RFInitial;
      LabelOptFlag = False;
      CalcBondsFlag = True;
+     CalcSurfFlag = False;
      AllowWrite = False;
  }
  
*** rasmol.c	2005/01/16 20:24:05	1.2
--- rasmol.c	2005/01/16 20:25:17
***************
*** 1046,1051 ****
--- 1052,1058 ----
                                  DisableWireframe();
                                  SetRibbonStatus(False,0,0);
                                  DisableBackbone();
+                                 DrawSurf = False;
                                  ReDrawFlag |= RFRefresh;
                                  break;
  
***************
*** 1079,1084 ****
--- 1086,1103 ----
                                  SetRibbonCartoons();
                                  DisableBackbone();
                                  ReDrawFlag |= RFRefresh;
+                                 break;
+ 
+                       case(9):  /* MolSurf */
+                                 DrawSurf = True;
+                                 ProbeRadius = 350;
+                                 SetVanWaalRadius(SphereFlag | TouchFlag);
+                                 DisableWireframe();
+                                 SetRibbonStatus(False,0,0);
+                                 DisableBackbone();
+                                 CreateSurfaceBonds();
+                                 ReDrawFlag |= RFRefresh;
+                                 break;
                    }
                    break;
  
***************
*** 1481,1486 ****
--- 1500,1506 ----
      ProfCount = 0;
  
      CalcBondsFlag = True;
+     CalcSurfFlag = False;
      LabelOptFlag = False;
      FileFormat = FormatPDB;
      AllowWrite = False;
*** rastxt.c	2004/05/07 19:46:16	1.1
--- rastxt.c	2005/01/16 20:25:17
***************
*** 413,424 ****
  {
      register int i;
  
!     for( i=0; i<8; i++ )
          DialValue[i] = 0.0;
      
      XRange = x;   WRange = XRange>>1;
      YRange = y;   HRange = YRange>>1;
      Range = MinFun(XRange,YRange);
      
      /* Initialise Palette! */
      for( i=0; i<256; i++ )
--- 413,425 ----
  {
      register int i;
  
!     for( i=0; i<10; i++ )
          DialValue[i] = 0.0;
      
      XRange = x;   WRange = XRange>>1;
      YRange = y;   HRange = YRange>>1;
      Range = MinFun(XRange,YRange);
+     ZRange = 20000;
      
      /* Initialise Palette! */
      for( i=0; i<256; i++ )
***************
*** 495,500 ****
--- 496,502 ----
  
      FileFormat = FormatPDB;
      CalcBondsFlag = True;
+     CalcSurfFlag = False;
  }
  
  
*** raswin.c	2004/05/07 19:46:16	1.1
--- raswin.c	2005/01/16 20:25:17
***************
*** 1983,1988 ****
--- 1989,2007 ----
  			      ReDrawFlag |= RFRefresh;
  			      break;
  
+ 	case(IDM_MOLSURF):    /* Molecular Surface */
+ 			      DrawSurf = True;
+ 			      ProbeRadius = 350;
+ 			      SetVanWaalRadius( SphereFlag | TouchFlag );
+ 			      DisableWireframe();
+ 			      SetRibbonStatus(False,0,0);
+ 			      DisableBackbone();
+ 			      CreateSurfaceBonds();
+ 			      ReDrawFlag |= RFRefresh;
+ 			      break;
+ 
+ 
+ 
  	/* Colours Menu */
  	case(IDM_MONO):     MonoColourAttrib(255,255,255);
  			    ReDrawFlag |= RFColour;  break;
***************
*** 2934,2939 ****
--- 2953,2959 ----
      snamebuf[0] = '\0';
  
      CalcBondsFlag = True;
+     CalcSurfFlag = False;
      LabelOptFlag = False;
      FileFormat = FormatPDB;
      AllowWrite = False;
*** render.c	2004/05/07 19:46:16	1.1
--- render.c	2005/01/16 20:25:17
***************
*** 155,179 ****
  
  #define PoolSize       16
  #define ApproxZero     1.0E-3
- #define RootSix        2.44948974278
  #define INFINITY       200000
  #define FUDGEFACTOR    1000
  
- #ifdef INVERT
- #define InvertY(y) (y)
- #define ProperY(y) (-y)
- #else
- #define InvertY(y) (-(y))
- #define ProperY(y) (y)
- #endif
- 
- 
- /* These define light source position */
- #define LightDot(x,y,z)  ((x)+(y)+(z)+(z))
- #define LightLength      RootSix
- #define LightXComp       1
- #define LightYComp       1
- #define LightZComp       2
  
  
  /* Macros for commonly used loops */
--- 121,129 ----
***************
*** 181,186 ****
--- 131,137 ----
                       for(group=chain->glist;group;group=group->gnext)    \
                       for(aptr=group->alist;aptr;aptr=aptr->anext)
  #define ForEachBond  for(bptr=Database->blist;bptr;bptr=bptr->bnext)
+ #define ForEachSurfBond  for(sbptr=Database->sblist;sbptr;sbptr=sbptr->sbnext)
  #define ForEachBack  for(chain=Database->clist;chain;chain=chain->cnext) \
                       for(bptr=chain->blist;bptr;bptr=bptr->bnext)
  
***************
*** 446,460 ****
      register int index;
      register long len, temp;
  
-     temp = (long)XRange*YRange*sizeof(short)+32;
  #ifdef MSWIN
      if( DBufHandle ) GlobalFree(DBufHandle);
      DBufHandle = GlobalAlloc(GMEM_MOVEABLE,temp);
      if( !DBufHandle ) FatalRenderError("depth buffer");
  #else
      if( DBuffer ) _ffree( DBuffer );
      DBuffer = (short*)_fmalloc( temp );
      if( !DBuffer ) FatalRenderError("depth buffer");
  #endif
      DBClear=False;
  
--- 397,413 ----
      register int index;
      register long len, temp;
  
  #ifdef MSWIN
+     temp = (long)XRange*YRange*sizeof(short)+32;
      if( DBufHandle ) GlobalFree(DBufHandle);
      DBufHandle = GlobalAlloc(GMEM_MOVEABLE,temp);
      if( !DBufHandle ) FatalRenderError("depth buffer");
  #else
+     temp = (long)XRange*YRange*sizeof(short)+32;
      if( DBuffer ) _ffree( DBuffer );
      DBuffer = (short*)_fmalloc( temp );
      if( !DBuffer ) FatalRenderError("depth buffer");
+     temp = (long)XRange*YRange*sizeof(int)+32;
  #endif
      DBClear=False;
  
***************
*** 542,551 ****
      for( scan=0; scan<BuckY; scan++ )
  	*temp++ = (void __far*)0;
  
      if( UseClipping )
      {   ForEachAtom
! 	    if( aptr->flag&SphereFlag )
  	    {   rad = aptr->irad;
  		if( (aptr->x-rad>=XRange) || 
  		    (aptr->x+rad<0) || (aptr->y+rad<0) )
  		    continue;
--- 495,507 ----
      for( scan=0; scan<BuckY; scan++ )
  	*temp++ = (void __far*)0;
  
+     iProbeRad = (int)rint(Scale*ProbeRadius);
+ 
      if( UseClipping )
      {   ForEachAtom
! 	    if( aptr->flag&(SphereFlag|TouchFlag) )
  	    {   rad = aptr->irad;
+                 if (aptr->flag&ExpandFlag) rad += iProbeRad;
  		if( (aptr->x-rad>=XRange) || 
  		    (aptr->x+rad<0) || (aptr->y+rad<0) )
  		    continue;
***************
*** 561,568 ****
  	    }
      } else
  	ForEachAtom
! 	    if( aptr->flag&SphereFlag )
  	    {   scan = aptr->y-aptr->irad;
  		aptr->bucket = YBucket[scan];
  		YBucket[scan] = aptr;
  	    }
--- 517,525 ----
  	    }
      } else
  	ForEachAtom
! 	    if( aptr->flag&(SphereFlag|TouchFlag) )
  	    {   scan = aptr->y-aptr->irad;
+                 if (aptr->flag&ExpandFlag) scan -= iProbeRad;
  		aptr->bucket = YBucket[scan];
  		YBucket[scan] = aptr;
  	    }
***************
*** 667,674 ****
  	if( flag != SphereFlag )
  	{   if( SolventDots || !ProbeRadius )
  	    {   rad = ElemVDWRadius(aptr->elemno);
! 	    } else rad = ProbeRadius;
! 	} else rad = aptr->radius;  
  	radius2 = (Long)rad*rad;
  
  	lvx = (int)((mx-rad)*IVoxRatio);  hvx = (int)((mx+rad)*IVoxRatio);
--- 624,632 ----
  	if( flag != SphereFlag )
  	{   if( SolventDots || !ProbeRadius )
  	    {   rad = ElemVDWRadius(aptr->elemno);
! 	    } else rad = ElemVDWRadius(aptr->elemno)+ProbeRadius;
! 	} else rad = aptr->radius +
!             (aptr->flag&ExpandFlag)?ProbeRadius:0;  
  	radius2 = (Long)rad*rad;
  
  	lvx = (int)((mx-rad)*IVoxRatio);  hvx = (int)((mx+rad)*IVoxRatio);
***************
*** 852,858 ****
      register short __huge *dbase;
      register short __huge *dptr;
      register Pixel __huge *fptr;
-     register Byte __far *tptr;
  
      register int pos,depth,inten;
      register int lastx,wide,scan;
--- 810,815 ----
***************
*** 875,891 ****
  	prev = &list;
  	for( ptr=list; ptr; ptr=ptr->next )
  	{   dy = scan - ptr->y;
! 	    wide = LookUp[ptr->irad][AbsFun(dy)];
  	    lastx = (XRange-1)-ptr->x;
  	    if( wide<lastx ) lastx=wide;
  	    dx = - MinFun(wide,ptr->x);
  
  	    iptr = IBuffer+ptr->x;
- 	    tptr = LookUp[wide];
  
  	    dptr = dbase+ptr->x+dx;
  	    while( dx<=lastx )
! 	    {   depth = tptr[AbsFun(dx)]+ptr->z;
  		UpdateScanAcross;
  	    }
  
--- 832,847 ----
  	prev = &list;
  	for( ptr=list; ptr; ptr=ptr->next )
  	{   dy = scan - ptr->y;
! 	    wide = pythag(ptr->irad,AbsFun(dy));
  	    lastx = (XRange-1)-ptr->x;
  	    if( wide<lastx ) lastx=wide;
  	    dx = - MinFun(wide,ptr->x);
  
  	    iptr = IBuffer+ptr->x;
  
  	    dptr = dbase+ptr->x+dx;
  	    while( dx<=lastx )
! 	    {   depth = pythag(wide,AbsFun(dx))+ptr->z;
  		UpdateScanAcross;
  	    }
  
***************
*** 937,1006 ****
      register Group __far *group;
      register RAtom __far *aptr;
  
      if( UseShadow )
      {   if( !BucketFlag )
  	    PrepareYBucket();
  	ScanLine();
      } else if( UseClipping )
      {   ForEachAtom
! 	    if( aptr->flag&SphereFlag )
! 		ClipSphere(aptr->x,aptr->y,aptr->z,aptr->irad,aptr->col);
      } else 
  	ForEachAtom
! 	    if( aptr->flag&SphereFlag )
! 		DrawSphere(aptr->x,aptr->y,aptr->z,aptr->irad,aptr->col);
  }
  
  static void DisplayStars( void )
  {
      register Chain __far *chain;
      register Group __far *group;
      register RAtom __far *aptr;
  
      if( UseClipping )
      {   ForEachAtom
  	    if( aptr->flag&StarFlag )
! 		ClipStar(aptr->x,aptr->y,aptr->z,aptr->radius,aptr->col);
      } else 
  	ForEachAtom
  	    if( aptr->flag&StarFlag )
! 		DrawStar(aptr->x,aptr->y,aptr->z,aptr->radius,aptr->col);
  }
  
  
  static void DisplayWireframe( void )
  {
      register Bond __far *bptr;
      register RAtom __far *s;
      register RAtom __far *d;
!     register int sc,dc;
  
      if( UseClipping )
      {   ForEachBond
  	   if( bptr->flag & DrawBondFlag )
             {   s = bptr->srcatom; d = bptr->dstatom;
! 	       if( !bptr->col ) 
! 	       {   sc = s->col;  dc = d->col;
! 	       } else sc = dc = bptr->col;
  
  	       if( bptr->flag&WireFlag )
  	       {   ClipTwinVector(s->x,s->y,s->z,d->x,d->y,d->z,sc,dc,bptr->altl);
  	       } else if( bptr->flag&CylinderFlag )
  	       {   if( bptr->irad>0 )
  	           {  ClipCylinder(s->x,s->y,s->z,d->x,d->y,d->z,
!                                    sc,dc,bptr->irad, bptr->altl,bptr->iarad);
  	           } else ClipTwinLine(s->x,s->y,s->z,d->x,d->y,d->z,
  				   sc+ColourMask,dc+ColourMask,bptr->altl);
                 } else /* bptr->flag & DashFlag */
                     ClipDashVector(s->x,s->y,s->z,d->x,d->y,d->z,sc,dc,bptr->altl);
  	   }
!     } else
  	ForEachBond
  	   if( bptr->flag & DrawBondFlag )
             {   s = bptr->srcatom; d = bptr->dstatom;
                 if( !bptr->col )
                 {   sc = s->col;  dc = d->col;
!                } else sc = dc = bptr->col;
  
                 if( bptr->flag&WireFlag )
                 {      DrawTwinVector(s->x,s->y,s->z,d->x,d->y,d->z,sc,dc,
--- 893,991 ----
      register Group __far *group;
      register RAtom __far *aptr;
  
+     iProbeRad = (int)rint(Scale*(Real)ProbeRadius);
      if( UseShadow )
      {   if( !BucketFlag )
  	    PrepareYBucket();
  	ScanLine();
      } else if( UseClipping )
      {   ForEachAtom
! 	    if( aptr->flag&(SphereFlag|TouchFlag) )
! 		ClipSphere(aptr->x,aptr->y,aptr->z,
!                     aptr->irad+((aptr->flag&ExpandFlag)?iProbeRad:0),
!                     aptr->col);
      } else 
  	ForEachAtom
! 	    if( aptr->flag&(SphereFlag|TouchFlag) )
! 		DrawSphere(aptr->x,aptr->y,aptr->z,
!                     aptr->irad+((aptr->flag&ExpandFlag)?iProbeRad:0),
!                     aptr->col);
  }
  
+ 
  static void DisplayStars( void )
  {
      register Chain __far *chain;
      register Group __far *group;
      register RAtom __far *aptr;
  
+     iProbeRad = (int)rint(Scale*ProbeRadius);
+ 
      if( UseClipping )
      {   ForEachAtom
  	    if( aptr->flag&StarFlag )
! 		ClipStar(aptr->x,aptr->y,aptr->z,
!                   aptr->radius+(aptr->flag&ExpandFlag?ProbeRadius:0),
!                   aptr->col);
      } else 
  	ForEachAtom
  	    if( aptr->flag&StarFlag )
! 		DrawStar(aptr->x,aptr->y,aptr->z,
!                   aptr->radius+(aptr->flag&ExpandFlag?ProbeRadius:0),
!                   aptr->col);
  }
  
  
  static void DisplayWireframe( void )
  {
      register Bond __far *bptr;
+     register SurfBond __far *sbptr;
      register RAtom __far *s;
      register RAtom __far *d;
!     register int sc,dc,stmp;
! 	
!     iProbeRad = (int)rint(Scale*(Real)ProbeRadius);
  
      if( UseClipping )
      {   ForEachBond
  	   if( bptr->flag & DrawBondFlag )
             {   s = bptr->srcatom; d = bptr->dstatom;
! 
! 
! 
! 	       if( !bptr->col ) {
! 	         sc = s->col;  dc = d->col;
! 	       } else {
!                  sc = dc = bptr->col;
! 
! 
!                }
  
  	       if( bptr->flag&WireFlag )
  	       {   ClipTwinVector(s->x,s->y,s->z,d->x,d->y,d->z,sc,dc,bptr->altl);
  	       } else if( bptr->flag&CylinderFlag )
  	       {   if( bptr->irad>0 )
  	           {  ClipCylinder(s->x,s->y,s->z,d->x,d->y,d->z,
!                                    sc,dc,bptr->irad, bptr->altl, bptr->iarad);
  	           } else ClipTwinLine(s->x,s->y,s->z,d->x,d->y,d->z,
  				   sc+ColourMask,dc+ColourMask,bptr->altl);
                 } else /* bptr->flag & DashFlag */
                     ClipDashVector(s->x,s->y,s->z,d->x,d->y,d->z,sc,dc,bptr->altl);
  	   }
!     } else {
  	ForEachBond
  	   if( bptr->flag & DrawBondFlag )
             {   s = bptr->srcatom; d = bptr->dstatom;
+ 
+ 
+ 
                 if( !bptr->col )
                 {   sc = s->col;  dc = d->col;
!                } else {
!                  sc = dc = bptr->col;
! 
! 
!                }
  
                 if( bptr->flag&WireFlag )
                 {      DrawTwinVector(s->x,s->y,s->z,d->x,d->y,d->z,sc,dc,
***************
*** 1014,1019 ****
--- 999,1072 ----
  	       } else ClipDashVector(s->x,s->y,s->z,d->x,d->y,d->z,sc,dc,
                          bptr->altl);
             }
+      } 
+      if (DrawSurf && DrawAtoms)
+      ForEachSurfBond
+      {   s = sbptr->srcatom; d = sbptr->dstatom;
+ 	     if (s->flag&SelectFlag && d->flag&SelectFlag
+ 	         && !(s->flag&ExpandFlag || d->flag&ExpandFlag )) {
+ 
+ 
+ 
+          if( !sbptr->col ) {
+            sc = s->col;  dc = d->col;
+          } else {
+            sc = dc = sbptr->col;
+ 
+ 
+          }
+          SBD.rad = s->irad;
+          if (d->irad > SBD.rad) SBD.rad = d->irad;
+          if (iProbeRad > SBD.rad) SBD.rad = iProbeRad;
+          SBD.x1 = s->x;
+          SBD.y1 = s->y;
+          SBD.z1 = s->z;
+          SBD.x2 = d->x;
+          SBD.y2 = d->y;
+          SBD.z2 = d->z;
+          SBD.U[0] = SBD.x2-SBD.x1;
+          SBD.U[1] = SBD.y2-SBD.y1;
+          SBD.U[2] = SBD.z2-SBD.z1;
+          SBD.sxyz = (LScale*sbptr->sxyz)>>4;
+          SBD.c1 = sc;
+          SBD.c2 = dc;
+          SBD.u1 = (LScale*sbptr->u1)>>4;
+          SBD.u2 = (LScale*sbptr->u2)>>4;
+          SBD.wp = (LScale*sbptr->wp)>>4;
+          SBD.t1 = (LScale*sbptr->t1)>>4;
+          SBD.t2 = (LScale*sbptr->t2)>>4;
+          SBD.w1 = (LScale*sbptr->w1)>>4;
+          SBD.w2 = (LScale*sbptr->w2)>>4;
+ 
+          SBD.s0=0;
+          SBD.s1=1;
+          SBD.s2=2;
+ 
+          if (AbsFun(SBD.U[0]) > AbsFun(SBD.U[1])) {
+              SBD.s0 = 1;
+              SBD.s1 = 0;
+          }
+          if (AbsFun(SBD.U[SBD.s1]) > AbsFun(SBD.U[2])) {
+              stmp = SBD.s1;
+              SBD.s1 = SBD.s2;
+              SBD.s2 = stmp;
+          }
+          if (AbsFun(SBD.U[SBD.s0]) > AbsFun(SBD.U[SBD.s1])) {
+              stmp = SBD.s0;
+              SBD.s0 = SBD.s1;
+              SBD.s1 = stmp;
+          }
+ 
+          SBD.Us0Us1 = SBD.U[SBD.s0]*SBD.U[SBD.s1];
+          SBD.Us0Us0_Us2Us2 = SBD.U[SBD.s0]*SBD.U[SBD.s0]+SBD.U[SBD.s2]*SBD.U[SBD.s2];
+          SBD.Us1Us1_Us2Us2 = SBD.U[SBD.s1]*SBD.U[SBD.s1]+SBD.U[SBD.s2]*SBD.U[SBD.s2];
+          SBD.Us0Us0_Us1Us1_Us2Us2 = SBD.U[SBD.s0]*SBD.U[SBD.s0]+
+              SBD.U[SBD.s1]*SBD.U[SBD.s1]+SBD.U[SBD.s2]*SBD.U[SBD.s2];
+ 	     ClipSurfaceBond(s->x,s->y,s->z,d->x,d->y,d->z,
+                  sc,dc, s->irad,d->irad, iProbeRad, sbptr->altl);
+ 	   }
+      }
+ 
  }
  
  
***************
*** 1425,1431 ****
      register int irad,sc,dc;
      register int col;
  
!     irad = (int)(Scale*20);
  
      if( irad>0 )
      {   ForEachBond
--- 1478,1484 ----
      register int irad,sc,dc;
      register int col;
  
!     irad = (int)rint(Scale*20);
  
      if( irad>0 )
      {   ForEachBond
***************
*** 1452,1458 ****
  	}
  
  
!     irad = (int)(Scale*50);
      ForEachAtom
  	if( aptr->flag&NonBondFlag )
  	{   col = Shade2Colour( (aptr->flag&SelectFlag)? 1 : 0 );
--- 1505,1511 ----
  	}
  
  
!     irad = (int)rint(Scale*50);
      ForEachAtom
  	if( aptr->flag&NonBondFlag )
  	{   col = Shade2Colour( (aptr->flag&SelectFlag)? 1 : 0 );
***************
*** 1464,1473 ****
  static void RenderFrame( void )
  {
      register Chain __far *chain;
  
      if( !DisplayMode )
      {   if( DrawAtoms ) 
! 	    DisplaySpaceFill();
          if( DrawStars )
              DisplayStars();
  
--- 1517,1533 ----
  static void RenderFrame( void )
  {
      register Chain __far *chain;
+     int dwf;
+ 
+     dwf = 0;
  
      if( !DisplayMode )
      {   if( DrawAtoms ) 
!         DisplaySpaceFill();
!         if( DrawSurf ) {
!           DisplayWireframe();
!           dwf++;
!         }
          if( DrawStars )
              DisplayStars();
  
***************
*** 1475,1481 ****
  	{   if( DrawBonds ) 
              {   if( DrawDoubleBonds )
                  {   DisplayDoubleBonds();
!                 } else DisplayWireframe();
              }
  
  	    if( DrawRibbon )
--- 1535,1544 ----
  	{   if( DrawBonds ) 
              {   if( DrawDoubleBonds )
                  {   DisplayDoubleBonds();
!                 } else {
!                   if (!dwf) DisplayWireframe();
!                   dwf++;
!                 }
              }
  
  	    if( DrawRibbon )
***************
*** 1542,1547 ****
--- 1605,1612 ----
      /* Common View Elements */
      View.yskip = XRange;
      View.ymax = YRange;
+     View.fbuf = FBuffer;
+     View.dbuf = DBuffer;
  
      if( UseStereo )
      {
***************
*** 1549,1557 ****
          wide = XRange>>1;
  
          /* Create 'Left' View structure */
!         View.fbuf = FBuffer;
!         View.dbuf = DBuffer;
          View.xmax = wide;
  
          DialValue[DialRY] -= temp;
          ReDrawFlag |= RFRotateY;
--- 1614,1622 ----
          wide = XRange>>1;
  
          /* Create 'Left' View structure */
!         View.shift = 0;
          View.xmax = wide;
+         View.offmax = 2*wide*YRange;
  
          DialValue[DialRY] -= temp;
          ReDrawFlag |= RFRotateY;
***************
*** 1559,1567 ****
          RenderFrame();
  
          /* Create 'Right' View structure */
!         View.fbuf = FBuffer+wide;
!         View.dbuf = DBuffer+wide;
          View.xmax = wide;
  
          DialValue[DialRY] += temp;
          ReDrawFlag |= RFRotateY;
--- 1624,1632 ----
          RenderFrame();
  
          /* Create 'Right' View structure */
!         View.shift = wide;
          View.xmax = wide;
+         View.offmax = 2*wide*YRange;
  
          DialValue[DialRY] += temp;
          ReDrawFlag |= RFRotateY;
***************
*** 1570,1578 ****
  
      } else /* Mono */
      {   /* Create 'Mono' View structure */
!         View.fbuf = FBuffer;
!         View.dbuf = DBuffer;
          View.xmax = XRange;
          RenderFrame();
      }
  
--- 1635,1643 ----
  
      } else /* Mono */
      {   /* Create 'Mono' View structure */
!         View.shift = 0;
          View.xmax = XRange;
+         View.offmax = XRange*YRange;
          RenderFrame();
      }
  
***************
*** 1712,1735 ****
  	    }
  
  	    if( aptr->flag & (SphereFlag | StarFlag) )
! 	    {   dy = AbsFun(aptr->y-ypos);
! 		if( dy>aptr->irad ) continue;
! 		rad = LookUp[aptr->irad][dy];
  		dx = AbsFun(aptr->x-xpos);
  		if( dx>rad ) continue;
  
  		new = False;
! 		dpth = aptr->z+LookUp[rad][dx];
  		if( UseSlabPlane && (aptr->z+rad>=SlabValue) )
  		{   dz = SlabValue-aptr->z;
  		    if( SlabMode && (dz >= -rad) )
! 		    {   wide = LookUp[aptr->irad][AbsFun(dz)];
! 			if( (dy<=wide) && (dx<=(int)(LookUp[wide][dy])) )
  			{   if( SlabMode == SlabFinal )
  			    {   dpth = SliceValue;
  				new = True;
  			    } else if( SlabMode == SlabHollow )
! 			    {   dpth = aptr->z-LookUp[rad][dx];
  				new = !IdentFound || (dpth>IdentDepth);
  			    } else if( SlabMode != SlabHalf )
  			    {   /* SlabClose, SlabSection */
--- 1777,1804 ----
  	    }
  
  	    if( aptr->flag & (SphereFlag | StarFlag) )
! 	    {   int xrad;
! 
!                 xrad = aptr->irad;
!                 if (aptr->flag&ExpandFlag) xrad+=iProbeRad;
!                 dy = AbsFun(aptr->y-ypos);
! 		if( dy > xrad ) continue;
! 		rad = pythag(xrad,dy);
  		dx = AbsFun(aptr->x-xpos);
  		if( dx>rad ) continue;
  
  		new = False;
! 		dpth = aptr->z+pythag(rad,dx);
  		if( UseSlabPlane && (aptr->z+rad>=SlabValue) )
  		{   dz = SlabValue-aptr->z;
  		    if( SlabMode && (dz >= -rad) )
! 		    {   wide = pythag(aptr->irad,AbsFun(dz));
! 			if( (dy<=wide) && (dx<=pythag(wide,dy)) )
  			{   if( SlabMode == SlabFinal )
  			    {   dpth = SliceValue;
  				new = True;
  			    } else if( SlabMode == SlabHollow )
! 			    {   dpth = aptr->z-pythag(rad,dx);
  				new = !IdentFound || (dpth>IdentDepth);
  			    } else if( SlabMode != SlabHalf )
  			    {   /* SlabClose, SlabSection */
***************
*** 2146,2151 ****
--- 2215,2221 ----
      DrawBonds = False;  MaxBondRadius = 0;
      DrawStars = False;
      DrawRibbon = False;
+     DrawSurf = False;
  
      SlabMode = SlabClose;
      UseSlabPlane = False;
*** render.h	2004/05/07 19:46:16	1.1
--- render.h	2005/01/16 20:25:16
***************
*** 135,141 ****
  
  #define ColBits          24
  
! #define VOXORDER       21
  #define VOXORDER2      (VOXORDER*VOXORDER)
  #define VOXSIZE        (VOXORDER2*VOXORDER)
  
--- 141,150 ----
  
  #define ColBits          24
  
! /* To handle larger molecules efficiently
!    use VOXORDER 32 or larger.  To save space
!    use VOXORDER 21 or smaller */
! #define VOXORDER       32
  #define VOXORDER2      (VOXORDER*VOXORDER)
  #define VOXSIZE        (VOXORDER2*VOXORDER)
  
***************
*** 175,180 ****
--- 184,191 ----
  int FBClear;
  
  
+ 
+ 
  Card __far *ColConst;
  #if defined(IBMPC) || defined(APPLEMAC)
  void __far * __far *HashTable;
***************
*** 187,192 ****
--- 198,204 ----
  Byte Array[MAXTABLE];
  #endif
  
+ 
  #else
  extern int UseDepthCue;
  extern int UseStereo,StereoView;
***************
*** 216,221 ****
--- 228,235 ----
  extern int FBClear;
  
  
+ 
+ 
  extern Card __far *ColConst;
  #if defined(IBMPC) || defined(APPLEMAC)
  extern void __far * __far *HashTable;
***************
*** 227,234 ****
--- 241,262 ----
  extern Byte *LookUp[MAXRAD];
  extern Byte Array[MAXTABLE];
  #endif
+ 
+ 
  #endif
  
+ #define pythag(h,x) \
+            ((h)<MAXRAD? \
+              (int)LookUp[(h)][(x)]: \
+              (int)(.5+(sqrt((double)((h)*(h)-(x)*(x))))))
+ #define apythag(h,x) \
+            ((h)<MAXRAD/2? \
+              (int)LookUp[(h)][(x)]: \
+              (int)(.5+(sqrt((double)((h)*(h)-(x)*(x))))))
+ #define colconst(r) \
+      ((r)<MAXRAD? \
+        ColConst[(r)] : \
+        (Card)(((Card)ColourDepth<<ColBits)/((int)(LightLength*(r)+4))))
  
  void ClearBuffers( void );
  void ReSizeScreen( void );
*** repres.c	2004/05/07 19:46:16	1.1
--- repres.c	2005/01/16 20:25:17
***************
*** 152,158 ****
  #endif
  
  /* These define light source position */
- #define LightDot(x,y,z)  ((x)+(y)+(z)+(z))
  #define LightLength      RootSix
  
  
--- 155,160 ----
***************
*** 818,824 ****
          {   aptr = item->data;
              if( !ProbeRadius )
              {   rad = ElemVDWRadius(aptr->elemno);
!             } else rad = ProbeRadius;
              rad = rad*rad;
   
              /* Optimized Test! */
--- 820,826 ----
          {   aptr = item->data;
              if( !ProbeRadius )
              {   rad = ElemVDWRadius(aptr->elemno);
!             } else rad = ElemVDWRadius(aptr->elemno)+ProbeRadius;
              rad = rad*rad;
   
              /* Optimized Test! */
***************
*** 920,926 ****
   
      if( SolventDots || !ProbeRadius )
      {   rad = ElemVDWRadius(elem);
!     } else rad = ProbeRadius;
   
      count = (int)(((Long)density*rad*rad)/((Long)250*250));
      ptr = (DotVector __far*)_fmalloc(count*sizeof(DotVector));
--- 922,928 ----
   
      if( SolventDots || !ProbeRadius )
      {   rad = ElemVDWRadius(elem);
!     } else rad = ElemVDWRadius(elem)+ProbeRadius;
   
      count = (int)(((Long)density*rad*rad)/((Long)250*250));
      ptr = (DotVector __far*)_fmalloc(count*sizeof(DotVector));
***************
*** 932,938 ****
          temp = rad + ProbeRadius;
      } else probe = NULL;
   
!     equat = (int)sqrt(PI*count);
      if( !(vert=equat>>1) )
          vert = 1;
   
--- 934,940 ----
          temp = rad + ProbeRadius;
      } else probe = NULL;
   
!     equat = (int)rint(sqrt(PI*count));
      if( !(vert=equat>>1) )
          vert = 1;
   
***************
*** 940,946 ****
      for( j=0; (i<count) && (j<vert); j++ )
      {   p = (PI*j)/(Real)vert;
          z = cos(p);  xy = sin(p);
!         horz = (int)(equat*xy);
          if( !horz ) horz = 1;
   
          for( k=0; (i<count) && (k<horz); k++ )
--- 942,948 ----
      for( j=0; (i<count) && (j<vert); j++ )
      {   p = (PI*j)/(Real)vert;
          z = cos(p);  xy = sin(p);
!         horz = (int)rint(equat*xy);
          if( !horz ) horz = 1;
   
          for( k=0; (i<count) && (k<horz); k++ )
***************
*** 948,960 ****
              x = xy*sin(q);
              y = xy*cos(q);
   
!             ptr[i].dx = (int)(rad*x);
!             ptr[i].dy = (int)(rad*y);
!             ptr[i].dz = (int)(rad*z);
              if( probe )
!             {   probe[i].dx = (int)(temp*x);
!                 probe[i].dy = (int)(temp*y);
!                 probe[i].dz = (int)(temp*z);
              }
              i++;
          }
--- 950,962 ----
              x = xy*sin(q);
              y = xy*cos(q);
   
!             ptr[i].dx = (int)rint(rad*x);
!             ptr[i].dy = (int)rint(rad*y);
!             ptr[i].dz = (int)rint(rad*z);
              if( probe )
!             {   probe[i].dx = (int)rint(temp*x);
!                 probe[i].dy = (int)rint(temp*y);
!                 probe[i].dz = (int)rint(temp*z);
              }
              i++;
          }
***************
*** 970,977 ****
      register int i;
   
      for( i=0; i<MAXELEMNO; i++ )
!         if( ElemDots[i].count )
              _ffree( ElemDots[i].dots );
      _ffree( ElemDots );
  }
   
--- 972,983 ----
      register int i;
   
      for( i=0; i<MAXELEMNO; i++ )
!         if( ElemDots[i].count ) {
              _ffree( ElemDots[i].dots );
+             if ( ElemDots[i].probe ) {
+               _ffree( ElemDots[i].probe );
+             }
+         }
      _ffree( ElemDots );
  }
   
***************
*** 1096,1104 ****
      register int i;
      register int Cenx,Ceny,Cenz;
      
!     Cenx=(int)(CenX*MatX[0]+CenY*MatX[1]+CenZ*MatX[2]);
! 	Ceny=(int)(CenX*MatY[0]+CenY*MatY[1]+CenZ*MatY[2]);
! 	Cenz=(int)(CenX*MatZ[0]+CenY*MatZ[1]+CenZ*MatZ[2]);
  
   
      for( ptr=DotPtr; ptr; ptr=ptr->next )
--- 1102,1110 ----
      register int i;
      register int Cenx,Ceny,Cenz;
      
!     Cenx=(int)rint(CenX*MatX[0]+CenY*MatX[1]+CenZ*MatX[2]);
!     Ceny=(int)rint(CenX*MatY[0]+CenY*MatY[1]+CenZ*MatY[2]);
!     Cenz=(int)rint(CenX*MatZ[0]+CenY*MatZ[1]+CenZ*MatZ[2]);
  
   
      for( ptr=DotPtr; ptr; ptr=ptr->next )
***************
*** 1107,1117 ****
              y = ptr->ypos[i];
              z = ptr->zpos[i];
   
!             xi = (int)(x*MatX[0]+y*MatX[1]+z*MatX[2])+XOffset-Cenx;
              if( XValid(xi) )
!             {   yi = (int)(x*MatY[0]+y*MatY[1]+z*MatY[2])+YOffset-Ceny;
                  if( YValid(yi) )
!                 {   zi = (int)(x*MatZ[0]+y*MatZ[1]+z*MatZ[2])+ZOffset-Cenz;
                      if( ZValid(zi) && ZBack(zi) )
                          PlotDeepPoint(xi,yi,zi,ptr->col[i]);
                  }
--- 1113,1123 ----
              y = ptr->ypos[i];
              z = ptr->zpos[i];
   
!             xi = (int)rint(x*MatX[0]+y*MatX[1]+z*MatX[2])+XOffset-Cenx;
              if( XValid(xi) )
!             {   yi = (int)rint(x*MatY[0]+y*MatY[1]+z*MatY[2])+YOffset-Ceny;
                  if( YValid(yi) )
!                 {   zi = (int)rint(x*MatZ[0]+y*MatZ[1]+z*MatZ[2])+ZOffset-Cenz;
                      if( ZValid(zi) && ZBack(zi) )
                          PlotDeepPoint(xi,yi,zi,ptr->col[i]);
                  }
*** repres.h	2004/05/07 19:46:16	1.1
--- repres.h	2005/01/16 20:25:16
***************
*** 136,141 ****
--- 139,145 ----
  int CartoonHeight;
  int SolventDots;
  int ProbeRadius;
+ int iProbeRad;
  
  int SurfaceChainsFlag;
  int DotDensity;
***************
*** 152,157 ****
--- 156,162 ----
  
  extern int CartoonHeight;
  extern int ProbeRadius;
+ extern int iProbeRad;
  extern int SolventDots;
  
  extern int SurfaceChainsFlag;
*** tokens.c	2004/05/07 19:46:16	1.1
--- tokens.c	2005/01/16 20:25:17
***************
*** 912,917 ****
--- 915,921 ----
          MOL2                 Mol2Tok
          MOLECULE             MoleculeTok
          MOLSCRIPT            MolScriptTok
+         MOLSURF		     MolSurfTok
          MONITOR              MonitorTok
          MONITORS             MonitorTok
          MONO                 MonoTok
***************
*** 964,969 ****
--- 968,975 ----
  		                return( MoleculeTok );
                      } else if( !strcmp(ptr,"LSCRIPT") ) {
                          return( MolScriptTok );
+                     } else if( !strcmp(ptr,"LSURF") ) {
+                         return( MolSurfTok );
                      } else if( !strcmp(ptr,"NITOR") ) {
                          return( MonitorTok );
                      } else if( !strcmp(ptr,"NITORS") ) {
*** tokens.h	2004/05/07 19:46:16	1.1
--- tokens.h	2005/01/16 20:25:16
***************
*** 126,131 ****
--- 129,135 ----
  #define LoadTok        276
  #define LoopTok        277
  #define MoleculeTok    278
+ #define MolSurfTok     255     // pzh: this may have to be changed 
  #define MonitorTok     279
  #define MoveTok        280
  #define PrintTok       281
*** transfor.c	2004/05/07 19:46:16	1.1
--- transfor.c	2005/01/16 20:25:17
***************
*** 122,127 ****
--- 125,132 ----
  #endif
  #endif
  #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
  #include <math.h>
  
  #define TRANSFORM
***************
*** 136,142 ****
  #include "multiple.h" /* [GSG 11/9/95] */
  #include "vector.h"   /* [GSG 11/14/95] */
  #include "wbrotate.h" /* [GSG 11/14/95] */
! 
  
  #define CPKMAX  16
  static ShadeRef CPKShade[] = {
--- 141,147 ----
  #include "multiple.h" /* [GSG 11/9/95] */
  #include "vector.h"   /* [GSG 11/14/95] */
  #include "wbrotate.h" /* [GSG 11/14/95] */
! #include "langsel.h"
  
  #define CPKMAX  16
  static ShadeRef CPKShade[] = {
***************
*** 251,256 ****
--- 256,262 ----
                       for(group=chain->glist;group;group=group->gnext)    \
                       for(ptr=group->alist;ptr;ptr=ptr->anext)
  #define ForEachBond  for(bptr=Database->blist;bptr;bptr=bptr->bnext) 
+ #define ForEachSurfBond  for(sbptr=Database->sblist;sbptr;sbptr=sbptr->sbnext)
  #define ForEachBack  for(chain=Database->clist;chain;chain=chain->cnext) \
                       for(bptr=chain->blist;bptr;bptr=bptr->bnext)
  
***************
*** 266,272 ****
      register int max;
  
      max = 0;
!     if( (DrawAtoms || DrawStars) && (MaxAtomRadius>max) )  max = MaxAtomRadius;
      if( DrawBonds && (MaxBondRadius>max) )  max = MaxBondRadius;
         
      temp = ImageRadius + max;
--- 272,279 ----
      register int max;
  
      max = 0;
!     if( (DrawAtoms || DrawStars || DrawSurf) && (MaxAtomRadius>max) )
!       max = MaxAtomRadius;
      if( DrawBonds && (MaxBondRadius>max) )  max = MaxBondRadius;
         
      temp = ImageRadius + max;
***************
*** 284,329 ****
      register Chain __far *chain;
      register Group __far *group;
      register RAtom __far *ptr;
  
      if( !Database )
          return;
  
!     irad = (int)(Scale*(Real)(rad));
      MaxAtomRadius = 0;
  	DrawAtoms = False;
  	DrawStars = False; 
       change = False;
  
      ForEachAtom
          if( ptr->flag & SelectFlag )
!         {   if( irad>MaxAtomRadius )
!                 MaxAtomRadius = irad;
! 			if (flag == SphereFlag )
! 			{	ptr->flag |= SphereFlag;
! 				ptr->flag &= ~StarFlag;
! 			} else
! 			{	ptr->flag |= StarFlag;
! 				ptr->flag &= ~SphereFlag;
  			}
              ptr->radius = rad;
              ptr->irad = irad;
              change = True;
          } else if( ptr->flag & SphereFlag )
          {	DrawAtoms = True;
!             if( ptr->irad>MaxAtomRadius )
!                 MaxAtomRadius = ptr->irad;
          } else if( ptr->flag & StarFlag )
  		{	DrawStars = True;
!             if( ptr->irad>MaxAtomRadius )
!                 MaxAtomRadius = ptr->irad;
          }
  
      if( change )
!     {   if (flag == SphereFlag )
          { DrawAtoms = True;
!         } else { 
!           DrawStars = True;
!         }
          DetermineClipping();
          VoxelsClean = False;
          BucketFlag = False;
--- 291,349 ----
      register Chain __far *chain;
      register Group __far *group;
      register RAtom __far *ptr;
+     register int incr;
  
      if( !Database )
          return;
  
!     irad = (int)rint(Scale*(Real)(rad));
!     iProbeRad = (int)rint(Scale*(Real)ProbeRadius);
      MaxAtomRadius = 0;
  	DrawAtoms = False;
  	DrawStars = False; 
+     DrawSurf = False; 
       change = False;
  
      ForEachAtom
+         {  incr = (ptr->flag&ExpandFlag)?iProbeRad:0;
          if( ptr->flag & SelectFlag )
!             {   if( (irad+incr)>MaxAtomRadius )
!                 MaxAtomRadius = irad+incr;
! 		if (flag & SphereFlag )
! 		{  ptr->flag |= SphereFlag|(flag&ExpandFlag);
! 		   ptr->flag &= ~(StarFlag|TouchFlag);
! 		} else if (flag & StarFlag)
! 		{  ptr->flag |= StarFlag|(flag&ExpandFlag);
!                    ptr->flag &= ~(SphereFlag|TouchFlag);
!                 } else if (flag & TouchFlag)
!                 {  ptr->flag |= TouchFlag|(flag&ExpandFlag);
!                    ptr->flag &= ~(SphereFlag|StarFlag);
  			}
              ptr->radius = rad;
              ptr->irad = irad;
              change = True;
          } else if( ptr->flag & SphereFlag )
          {	DrawAtoms = True;
!             if( (ptr->irad+incr)>MaxAtomRadius )
!                 MaxAtomRadius = ptr->irad+incr;
          } else if( ptr->flag & StarFlag )
  		{	DrawStars = True;
!             if( (ptr->irad+incr)>MaxAtomRadius )
!                 MaxAtomRadius = ptr->irad+incr;
!         } else if( ptr->flag & TouchFlag )
!               {       DrawSurf = True;
!             if( (ptr->irad+incr)>MaxAtomRadius )
!                 MaxAtomRadius = ptr->irad+incr;
!         }
          }
  
      if( change )
!     {   if ((flag&SphereFlag) == SphereFlag )
          { DrawAtoms = True;
!         } else if ((flag&StarFlag) == StarFlag )
!         { DrawStars = True;
!         } else
!           DrawSurf = True;
          DetermineClipping();
          VoxelsClean = False;
          BucketFlag = False;
***************
*** 337,342 ****
--- 357,363 ----
      register Chain __far *chain;
      register Group __far *group;
      register RAtom __far *ptr;
+     register int incr;
  
      if( !Database )
          return;
***************
*** 345,364 ****
  	DrawAtoms = False;
  	DrawStars = False; 
      change = False;
  
      ForEachAtom
          if( (ptr->flag&SelectFlag) && (ptr->temp>0) )
          {   rad = (5*ptr->temp)>>1;
              if( rad>750 ) rad = 750;
  
!             irad = (int)(Scale*(Real)(rad));
!             if( irad>MaxAtomRadius )
!                 MaxAtomRadius = irad;
  			if (flag == SphereFlag )
! 			{	ptr->flag |= SphereFlag;
  				ptr->flag &= ~StarFlag;
  			} else 
! 			{	ptr->flag |= StarFlag;
  				ptr->flag &= ~SphereFlag;
  			}
              ptr->radius = rad;
--- 366,387 ----
  	DrawAtoms = False;
  	DrawStars = False; 
      change = False;
+     iProbeRad = (int)rint(Scale*(Real)ProbeRadius);
  
      ForEachAtom
+         {  incr = (ptr->flag&ExpandFlag)?iProbeRad:0;
          if( (ptr->flag&SelectFlag) && (ptr->temp>0) )
          {   rad = (5*ptr->temp)>>1;
              if( rad>750 ) rad = 750;
  
!             irad = (int)rint(Scale*(Real)(rad));
!             if( irad+incr>MaxAtomRadius )
!                 MaxAtomRadius = irad+incr;
  			if (flag == SphereFlag )
! 			{	ptr->flag |= SphereFlag|(flag&ExpandFlag);
  				ptr->flag &= ~StarFlag;
  			} else 
! 			{	ptr->flag |= StarFlag|(flag&ExpandFlag);
  				ptr->flag &= ~SphereFlag;
  			}
              ptr->radius = rad;
***************
*** 366,381 ****
              change = True;
          } else if( ptr->flag & SphereFlag )
          {	DrawAtoms = True;
!             if( ptr->irad>MaxAtomRadius )
!                 MaxAtomRadius = ptr->irad;
          } else if( ptr->flag & StarFlag )
  		{	DrawStars = True;
!             if( ptr->irad>MaxAtomRadius )
!                 MaxAtomRadius = ptr->irad;
          }
  
      if( change )
!     {   if (flag == SphereFlag )
          { DrawAtoms = True;
          } else { 
            DrawStars = True;
--- 389,405 ----
              change = True;
          } else if( ptr->flag & SphereFlag )
          {	DrawAtoms = True;
!             if( (ptr->irad+incr)>MaxAtomRadius )
!                 MaxAtomRadius = ptr->irad+incr;
          } else if( ptr->flag & StarFlag )
  		{	DrawStars = True;
!             if( (ptr->irad+incr)>MaxAtomRadius )
!                 MaxAtomRadius = ptr->irad+incr;
!         }
          }
  
      if( change )
!     {   if ((flag&SphereFlag) == SphereFlag )
          { DrawAtoms = True;
          } else { 
            DrawStars = True;
***************
*** 400,438 ****
      MaxAtomRadius = 0;
  	DrawAtoms = False;
  	DrawStars = False; 
      change = False;
  
      ForEachAtom
          if( ptr->flag&SelectFlag )
          {   rad = ElemVDWRadius(ptr->elemno);
!             ptr->irad = (int)(Scale*(Real)(rad));
              ptr->radius = rad;
              change = True;
  
! 			if (flag == SphereFlag )
  			{	ptr->flag |= SphereFlag;
! 				ptr->flag &= ~StarFlag;
! 			} else 
  			{	ptr->flag |= StarFlag;
! 				ptr->flag &= ~SphereFlag;
  			}
              if( ptr->irad>MaxAtomRadius )
                  MaxAtomRadius = ptr->irad;
          } else if( ptr->flag & SphereFlag )
!         {	DrawAtoms = True;
!             if( ptr->irad>MaxAtomRadius )
!                 MaxAtomRadius = ptr->irad;
          } else if( ptr->flag & StarFlag )
! 		{	DrawStars = True;
!            if( ptr->irad>MaxAtomRadius )
!                 MaxAtomRadius = ptr->irad;
          }
  
      if( change )
!     {   if (flag == SphereFlag )
          { DrawAtoms = True;
!         } else { 
            DrawStars = True;
          }
          DetermineClipping();
          VoxelsClean = False;
--- 424,488 ----
      MaxAtomRadius = 0;
  	DrawAtoms = False;
  	DrawStars = False; 
+     DrawSurf = False; 
      change = False;
  
+     iProbeRad = (int)rint(Scale*(Real)ProbeRadius);
+ 
      ForEachAtom
          if( ptr->flag&SelectFlag )
          {   rad = ElemVDWRadius(ptr->elemno);
!             ptr->irad = (int)rint(Scale*(Real)(rad));
              ptr->radius = rad;
              change = True;
  
! 			if ( flag&SphereFlag )
  			{	ptr->flag |= SphereFlag;
! 				ptr->flag &= ~(StarFlag|TouchFlag);
! 			} else if ( flag&StarFlag )
  			{	ptr->flag |= StarFlag;
! 				ptr->flag &= ~(SphereFlag|TouchFlag);
! 			} else 
!                           {       ptr->flag |= TouchFlag;
!                                   ptr->flag &= ~(SphereFlag | StarFlag);
  			}
+             if (flag&ExpandFlag)
+             {
+               if( (ptr->irad)+iProbeRad>MaxAtomRadius )
+                 MaxAtomRadius = (ptr->irad)+iProbeRad;
+                 ptr->flag |= ExpandFlag;
+             } else {
              if( ptr->irad>MaxAtomRadius )
                  MaxAtomRadius = ptr->irad;
+                 ptr->flag &= ~ExpandFlag;
+             }
          } else if( ptr->flag & SphereFlag )
!         {   int iroff;
!             iroff = (ptr->flag&ExpandFlag)?iProbeRad:0;
!             DrawAtoms = True;
!             if( (ptr->irad)+iroff>MaxAtomRadius )
!                 MaxAtomRadius = (ptr->irad)+iroff;
          } else if( ptr->flag & StarFlag )
!           {   int iroff;
!               iroff = (ptr->flag&ExpandFlag)?iProbeRad:0;
!               DrawStars = True;
!               if( (ptr->irad)+iroff>MaxAtomRadius )
!               MaxAtomRadius = (ptr->irad)+iroff;
!         } else if( ptr->flag & TouchFlag )
!           {   int iroff;
!               iroff = (ptr->flag&ExpandFlag)?iProbeRad:0;
!               DrawSurf = True;
!               if( (ptr->irad)+iroff>MaxAtomRadius )
!               MaxAtomRadius = (ptr->irad)+iroff;
          }
  
      if( change )
!     {   if ((flag&SphereFlag) == SphereFlag )
          { DrawAtoms = True;
!         } else if ((flag&StarFlag) == StarFlag ) { 
            DrawStars = True;
+         } else if ((flag&TouchFlag) == TouchFlag ) { 
+           DrawSurf = True;
          }
          DetermineClipping();
          VoxelsClean = False;
***************
*** 446,451 ****
--- 496,502 ----
      register Chain __far *chain;
      register Group __far *group;
      register RAtom __far *ptr;
+     register int incr;
  
      if( !Database )
          return;
***************
*** 453,475 ****
      MaxAtomRadius = 0;
      DrawAtoms = False;
      DrawStars = False;
      
      ForEachAtom
          if( !(ptr->flag&SelectFlag) )
          {   if( ptr->flag&SphereFlag )
!             {   if( ptr->irad>MaxAtomRadius )
!                     MaxAtomRadius = ptr->irad;
                  DrawAtoms = True;
              } 
              if( ptr->flag&StarFlag )
!             {   if( ptr->irad>MaxAtomRadius )
!                     MaxAtomRadius = ptr->irad;
                  DrawStars = True;
              }
!         } else if( ptr->flag&SphereFlag || ptr->flag&StarFlag )
            {
!             ptr->flag &= ~SphereFlag;
!             ptr->flag &= ~StarFlag;
            }
  
      DetermineClipping();
--- 504,537 ----
      MaxAtomRadius = 0;
      DrawAtoms = False;
      DrawStars = False;
+     DrawSurf  = False;
+     iProbeRad = (int)rint(Scale*(Real)ProbeRadius);    
      
      ForEachAtom
+         {  incr = (ptr->flag&ExpandFlag)?iProbeRad:0;
          if( !(ptr->flag&SelectFlag) )
          {   if( ptr->flag&SphereFlag )
!             {   if( (ptr->irad+incr)>MaxAtomRadius )
!                     MaxAtomRadius = ptr->irad+incr;
                  DrawAtoms = True;
              } 
              if( ptr->flag&StarFlag )
!             {   if( (ptr->irad+incr)>MaxAtomRadius )
!                     MaxAtomRadius = ptr->irad+incr;
                  DrawStars = True;
              }
!             if( ptr->flag&TouchFlag )
!             {   if( (ptr->irad+incr)>MaxAtomRadius )
!                     MaxAtomRadius = ptr->irad+incr;
!                 DrawSurf = True;
!             }
!         } else if( ptr->flag&SphereFlag ||
!                    ptr->flag&StarFlag ||
!                    ptr->flag&TouchFlag ||
!                    ptr->flag&ExpandFlag )
            {
!             ptr->flag &= ~(SphereFlag|StarFlag|TouchFlag|ExpandFlag);
!           }
            }
  
      DetermineClipping();
***************
*** 492,500 ****
  
      DrawBonds = False;
      MaxBondRadius = 0;
!     irad = (int)(Scale*(Real)(rad));
      if ( arad < rad ) {
!       iarad = (int)(Scale*(Real)(arad));
      } else {
        iarad = irad;
      }
--- 554,562 ----
  
      DrawBonds = False;
      MaxBondRadius = 0;
!     irad = (int)rint(Scale*(Real)(rad));
      if ( arad < rad ) {
!       iarad = (int)rint(Scale*(Real)(arad));
      } else {
        iarad = irad;
      }
***************
*** 533,539 ****
  		starrad = 75;
  	  else
  		starrad = (int) (1.5*rad);
!       istarrad = (int)(Scale*(Real)(starrad));
        change = False;
        ForEachAtom
        { if ( (ptr->flag & SelectFlag) &&
--- 595,601 ----
  		starrad = 75;
  	  else
  		starrad = (int) (1.5*rad);
!       istarrad = (int)rint(Scale*(Real)(starrad));
        change = False;
        ForEachAtom
        { if ( (ptr->flag & SelectFlag) &&
***************
*** 603,611 ****
      if( !Database )
          return;
  
!     irad = (int)(Scale*(Real)(rad));
      if ( arad < rad ) {
!       iarad = (int)(Scale*(Real)(arad));
      } else {
        iarad = irad;
      }
--- 665,673 ----
      if( !Database )
          return;
  
!     irad = (int)rint(Scale*(Real)(rad));
      if ( arad < rad ) {
!       iarad = (int)rint(Scale*(Real)(arad));
      } else {
        iarad = irad;
      }
***************
*** 672,680 ****
          list = Database->slist;
      }
  
!     irad = (int)(Scale*(Real)(rad));
      if ( arad < rad ) {
!       iarad = (int)(Scale*(Real)(arad));
      } else {
        iarad = irad;
      }
--- 734,742 ----
          list = Database->slist;
      }
  
!     irad = (int)rint(Scale*(Real)(rad));
      if ( arad < rad ) {
!       iarad = (int)rint(Scale*(Real)(arad));
      } else {
        iarad = irad;
      }
***************
*** 906,911 ****
--- 968,974 ----
  void SelectArea( int mode, int count, int xo, int yo, int x, int y )
  {
      register Bond __far *bptr;
+ 	register SurfBond __far *sbptr;
      register Chain __far *chain;
      register Group __far *group;
      register RAtom __far *ptr;
***************
*** 972,982 ****
  	           if( (bptr->srcatom->flag&bptr->dstatom->flag) & SelectFlag )
  	           {   bptr->flag |= SelectFlag;
  	           } else bptr->flag &= ~SelectFlag;
! 	    } else
  	        ForEachBond
  	           if( (bptr->srcatom->flag|bptr->dstatom->flag) & SelectFlag )
  	           {   bptr->flag |= SelectFlag;
  	           } else bptr->flag &= ~SelectFlag;
  		DisplaySelectCount();
  	} else {	/*Go fast for quick redraw*/
  		if( mode==0 )
--- 1035,1054 ----
  	           if( (bptr->srcatom->flag&bptr->dstatom->flag) & SelectFlag )
  	           {   bptr->flag |= SelectFlag;
  	           } else bptr->flag &= ~SelectFlag;
! 	        ForEachSurfBond
! 	           if( (sbptr->srcatom->flag&sbptr->dstatom->flag) & SelectFlag )
! 	           {   sbptr->flag |= SelectFlag;
! 	           } else sbptr->flag &= ~SelectFlag;
! 	    } else {
  	        ForEachBond
  	           if( (bptr->srcatom->flag|bptr->dstatom->flag) & SelectFlag )
  	           {   bptr->flag |= SelectFlag;
  	           } else bptr->flag &= ~SelectFlag;
+ 	        ForEachSurfBond
+ 	           if( (sbptr->srcatom->flag|sbptr->dstatom->flag) & SelectFlag )
+ 	           {   sbptr->flag |= SelectFlag;
+ 	           } else sbptr->flag &= ~SelectFlag;
+ 	    }
  		DisplaySelectCount();
  	} else {	/*Go fast for quick redraw*/
  		if( mode==0 )
***************
*** 1000,1005 ****
--- 1072,1078 ----
  void SelectZone( int mask )
  {
      register Bond __far *bptr;
+     register SurfBond __far *sbptr;
      register Chain __far *chain;
      register Group __far *group;
      register RAtom __far *ptr;
***************
*** 1020,1037 ****
             if( (bptr->srcatom->flag&bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
             } else bptr->flag &= ~SelectFlag;
!     } else
          ForEachBond
             if( (bptr->srcatom->flag|bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
             } else bptr->flag &= ~SelectFlag;
! 
  }
  
  
  void RestrictZone( int mask )
  {
      register Bond __far *bptr;
      register Chain __far *chain;
      register Group __far *group;
      register RAtom __far *ptr;
--- 1093,1125 ----
             if( (bptr->srcatom->flag&bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
             } else bptr->flag &= ~SelectFlag;
!         ForEachSurfBond
!            if( (sbptr->srcatom->flag&sbptr->dstatom->flag) & SelectFlag )
!            {   sbptr->flag |= SelectFlag;
!                DrawSurf = True;
!                sbptr->dstatom->flag |= TouchFlag;
!                sbptr->srcatom->flag |= TouchFlag;
!            } else sbptr->flag &= ~SelectFlag;
!     } else {
          ForEachBond
             if( (bptr->srcatom->flag|bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
             } else bptr->flag &= ~SelectFlag;
!          ForEachSurfBond
!            if( (sbptr->srcatom->flag|sbptr->dstatom->flag) & SelectFlag )
!            {   sbptr->flag |= SelectFlag;
!                DrawSurf = True;
!                sbptr->dstatom->flag |= TouchFlag;
!                sbptr->srcatom->flag |= TouchFlag;
!            } else sbptr->flag &= ~SelectFlag;
!     }
  }
  
  
  void RestrictZone( int mask )
  {
      register Bond __far *bptr;
+     register SurfBond __far *sbptr;
      register Chain __far *chain;
      register Group __far *group;
      register RAtom __far *ptr;
***************
*** 1042,1047 ****
--- 1130,1136 ----
  
      DrawAtoms = False;   MaxAtomRadius = 0;
      DrawStars = False;
+     DrawSurf = False;
      DrawBonds = False;   MaxBondRadius = 0;
      
      SelectCount = 0;
***************
*** 1060,1067 ****
                  if( ptr->irad>MaxAtomRadius )
                      MaxAtomRadius = ptr->irad;
              }
          } else 
!         {   ptr->flag &= ~(SelectFlag|SphereFlag|StarFlag);
              if( ptr->label )
              {   DeleteLabel( (Label*)ptr->label );
                  ptr->label = (void*)0;
--- 1149,1165 ----
                  if( ptr->irad>MaxAtomRadius )
                      MaxAtomRadius = ptr->irad;
              }
+             if( ptr->flag & TouchFlag )
+             {   DrawSurf = True;
+                 if( ptr->irad>MaxAtomRadius )
+                      MaxAtomRadius = ptr->irad;
+             }
+             if( ptr->flag & ExpandFlag )
+             {  if( (ptr->irad)+iProbeRad > MaxAtomRadius )
+                    MaxAtomRadius = (ptr->irad)+iProbeRad;
+             }
          } else 
!         {   ptr->flag &= ~(SelectFlag|SphereFlag|StarFlag|TouchFlag|ExpandFlag);
              if( ptr->label )
              {   DeleteLabel( (Label*)ptr->label );
                  ptr->label = (void*)0;
***************
*** 1082,1087 ****
--- 1180,1196 ----
              } 
          } else bptr->flag &= ~(SelectFlag|DrawBondFlag);
      }
+     
+     ForEachSurfBond
+     {   /* Ignore ZoneBoth setting! */
+         flag = sbptr->dstatom->flag & sbptr->srcatom->flag;
+         if( flag & SelectFlag )
+         {   sbptr->flag |= SelectFlag;
+             DrawSurf = True;
+             sbptr->dstatom->flag |= TouchFlag;
+             sbptr->srcatom->flag |= TouchFlag;
+         } else sbptr->flag &= ~(SelectFlag);
+     }
  
      ForEachBack
      {   /* Ignore ZoneBoth setting! */
***************
*** 1116,1121 ****
--- 1225,1231 ----
  void SelectZoneExpr( Expr *expr )
  {
      register Bond __far *bptr;
+     register SurfBond __far *sbptr;
      register AtomSet __far *pset;
  	register int i;
  
***************
*** 1156,1172 ****
             if( (bptr->srcatom->flag&bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
             } else bptr->flag &= ~SelectFlag;
!     } else
          ForEachBond
             if( (bptr->srcatom->flag|bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
!            } else bptr->flag &= ~SelectFlag;
  }
  
  
  void RestrictZoneExpr( Expr *expr )
  {
      register Bond __far *bptr;
      register Chain __far *chain;
      register Group __far *group;
      register RAtom __far *ptr;
--- 1266,1293 ----
             if( (bptr->srcatom->flag&bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
             } else bptr->flag &= ~SelectFlag;
!         ForEachSurfBond
!            if( (sbptr->srcatom->flag&sbptr->dstatom->flag) & SelectFlag )
!            {   sbptr->flag |= SelectFlag;
!            } else sbptr->flag &= ~SelectFlag;
!     } else 
!     {
          ForEachBond
             if( (bptr->srcatom->flag|bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
!            } else bptr->flag &= ~SelectFlag;	
!         ForEachSurfBond
!            if( (sbptr->srcatom->flag|sbptr->dstatom->flag) & SelectFlag )
!            {   sbptr->flag |= SelectFlag;
!            } else sbptr->flag &= ~SelectFlag;
!     }
  }
  
  
  void RestrictZoneExpr( Expr *expr )
  {
      register Bond __far *bptr;
+     register SurfBond __far *sbptr;
      register Chain __far *chain;
      register Group __far *group;
      register RAtom __far *ptr;
***************
*** 1197,1204 ****
                          if( QAtom->irad>MaxAtomRadius )
                              MaxAtomRadius = QAtom->irad;
                      }
                  }  else 
!                 {   QAtom->flag &= ~(SelectFlag|SphereFlag|StarFlag);
                      if( QAtom->label )
                      {   DeleteLabel( (Label*)QAtom->label );
                          QAtom->label = (void*)0;
--- 1318,1331 ----
                          if( QAtom->irad>MaxAtomRadius )
                              MaxAtomRadius = QAtom->irad;
                      }
+                     if( QAtom->flag & ExpandFlag )
+                     {   if( (QAtom->irad)+iProbeRad>MaxAtomRadius )
+                             MaxAtomRadius = (QAtom->irad)+iProbeRad;
+                     }
+ 
                  }  else 
!                 {   QAtom->flag &=
!                         ~(SelectFlag|SphereFlag|StarFlag|ExpandFlag);
                      if( QAtom->label )
                      {   DeleteLabel( (Label*)QAtom->label );
                          QAtom->label = (void*)0;
***************
*** 1219,1224 ****
--- 1346,1363 ----
                  DrawBonds = True;
          } else bptr->flag &= ~(SelectFlag|DrawBondFlag);
      }
+     
+     ForEachSurfBond
+     {   /* Ignore ZoneBoth setting! */
+         flag = sbptr->dstatom->flag & sbptr->srcatom->flag;
+         if( flag & SelectFlag )
+         {   sbptr->flag |= SelectFlag;
+             DrawSurf = True;
+             sbptr->dstatom->flag |= TouchFlag;
+             sbptr->srcatom->flag |= TouchFlag;
+         } else sbptr->flag &= ~(SelectFlag);
+     }
+ 
  
      ForEachBack
      {   /* Ignore ZoneBoth setting! */
***************
*** 1251,1256 ****
--- 1390,1396 ----
  
  void SelectAtom( int shift, RAtom __far *PAtom, Group __far *PGroup )
  {	register Bond __far *bptr;
+     register SurfBond __far *sbptr;
  	
  	SelectCount = 0;
  	for( QChain=Database->clist; QChain; QChain=QChain->cnext )
***************
*** 1283,1297 ****
  		if( (bptr->srcatom->flag&bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
             } else bptr->flag &= ~SelectFlag;
! 	} else
!         ForEachBond
!            if( (bptr->srcatom->flag|bptr->dstatom->flag) & SelectFlag )
!            {   bptr->flag |= SelectFlag;
!            } else bptr->flag &= ~SelectFlag;
  }
  
  void SelectGroup( int shift, Group __far *PGroup )
  {	register Bond __far *bptr;
  
  	SelectCount = 0;
  	for( QChain=Database->clist; QChain; QChain=QChain->cnext )
--- 1423,1440 ----
  		if( (bptr->srcatom->flag&bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
             } else bptr->flag &= ~SelectFlag;
! 	} else {
! 	    ForEachSurfBond
!         if( (sbptr->srcatom->flag|sbptr->dstatom->flag) & SelectFlag )
!            {  sbptr->flag |= SelectFlag;
!            } else sbptr->flag &= ~SelectFlag;
! 
! 	}
  }
  
  void SelectGroup( int shift, Group __far *PGroup )
  {	register Bond __far *bptr;
+     register SurfBond __far *sbptr;
  
  	SelectCount = 0;
  	for( QChain=Database->clist; QChain; QChain=QChain->cnext )
***************
*** 1321,1335 ****
  		if( (bptr->srcatom->flag&bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
             } else bptr->flag &= ~SelectFlag;
! 	} else
          ForEachBond
             if( (bptr->srcatom->flag|bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
!            } else bptr->flag &= ~SelectFlag;
  }
  
  void SelectChain( int shift, Chain __far *PChain )
  {	register Bond __far *bptr;
  
  	SelectCount = 0;
  	for( QChain=Database->clist; QChain; QChain=QChain->cnext )
--- 1464,1488 ----
  		if( (bptr->srcatom->flag&bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
             } else bptr->flag &= ~SelectFlag;
!         ForEachSurfBond
! 		if( (sbptr->srcatom->flag&sbptr->dstatom->flag) & SelectFlag )
!            {   sbptr->flag |= SelectFlag;
!            } else sbptr->flag &= ~SelectFlag;
! 	} else {
          ForEachBond
             if( (bptr->srcatom->flag|bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
!            } else bptr->flag &= ~SelectFlag;		
!         ForEachSurfBond
!            if( (sbptr->srcatom->flag|sbptr->dstatom->flag) & SelectFlag )
!            {   sbptr->flag |= SelectFlag;
!            } else sbptr->flag &= ~SelectFlag;		
! 	}
  }
  
  void SelectChain( int shift, Chain __far *PChain )
  {	register Bond __far *bptr;
+     register SurfBond __far *sbptr;
  
  	SelectCount = 0;
  	for( QChain=Database->clist; QChain; QChain=QChain->cnext )
***************
*** 1359,1369 ****
  		if( (bptr->srcatom->flag&bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
             } else bptr->flag &= ~SelectFlag;
! 	} else
          ForEachBond
             if( (bptr->srcatom->flag|bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
!            } else bptr->flag &= ~SelectFlag;
  }
  
  
--- 1512,1531 ----
  		if( (bptr->srcatom->flag&bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
             } else bptr->flag &= ~SelectFlag;
!         ForEachSurfBond
! 		if( (sbptr->srcatom->flag&sbptr->dstatom->flag) & SelectFlag )
!            {   sbptr->flag |= SelectFlag;
!            } else sbptr->flag &= ~SelectFlag;
! 	} else {
          ForEachBond
             if( (bptr->srcatom->flag|bptr->dstatom->flag) & SelectFlag )
             {   bptr->flag |= SelectFlag;
!            } else bptr->flag &= ~SelectFlag;	
!         ForEachSurfBond
!            if( (sbptr->srcatom->flag|sbptr->dstatom->flag) & SelectFlag )
!            {   sbptr->flag |= SelectFlag;
!            } else sbptr->flag &= ~SelectFlag;
! 	}
  }
  
  
***************
*** 2385,2391 ****
  
          if( fields & MaskRadiusFlag )
          {   rad = match? mptr->radius : 375;
!             ptr->irad = (int)(Scale*(Real)(rad));
              ptr->flag |= SphereFlag;
              ptr->radius = rad;
  
--- 2547,2553 ----
  
          if( fields & MaskRadiusFlag )
          {   rad = match? mptr->radius : 375;
!             ptr->irad = (int)rint(Scale*(Real)(rad));
              ptr->flag |= SphereFlag;
              ptr->radius = rad;
  
***************
*** 2394,2400 ****
              change = True;
          }
      } else 
!     {   if( ptr->flag & SphereFlag )
          {   DrawAtoms = True;
          if( ptr->irad>MaxAtomRadius )
              MaxAtomRadius = ptr->irad;
--- 2556,2562 ----
              change = True;
          }
      } else 
!     {   if( ptr->flag & (SphereFlag|TouchFlag|ExpandFlag) )
          {   DrawAtoms = True;
          if( ptr->irad>MaxAtomRadius )
              MaxAtomRadius = ptr->irad;
***************
*** 2404,2409 ****
--- 2566,2581 ----
          if( ptr->irad>MaxAtomRadius )
              MaxAtomRadius = ptr->irad;
          }
+         if( ptr->flag & TouchFlag )
+         {   DrawSurf = True;
+         if( ptr->irad>MaxAtomRadius )
+             MaxAtomRadius = ptr->irad;
+         }
+         if( ptr->flag & ExpandFlag )
+         {
+           if( (ptr->irad)+iProbeRad>MaxAtomRadius )
+             MaxAtomRadius = (ptr->irad)+iProbeRad;
+         }
       }
  
      if( change )
***************
*** 2803,2809 ****
  
  }
  
! void RMat2RV( Real *RX, Real *RY, Real *RZ, 
    Real RMX[3], Real RMY[3], Real RMZ[3]  ) {
    
    Real SRX, SRY, SRZ, TRX, TRY, TRZ;
--- 2975,2981 ----
  
  }
  
! void RMat2RV( Real __far *RX, Real __far *RY, Real __far *RZ, 
    Real RMX[3], Real RMY[3], Real RMZ[3]  ) {
    
    Real SRX, SRY, SRZ, TRX, TRY, TRZ;
***************
*** 2892,2915 ****
       
      } 
  
!     LOffset[0] = WRange + (int)(Zoom*DialValue[DialTX]*XRange);
!     LOffset[1] = HRange + (int)(Zoom*DialValue[DialTY]*YRange);
!     LOffset[2] = 10000 + (int)(Zoom*DialValue[DialTZ]*ZRange);
          
  
      if ( ( DialValue[DialRX] != LastRX ) || 
           ( DialValue[DialRY] != LastRY ) ||
           ( DialValue[DialRZ] != LastRZ ) ) {
           
- /*      RV2RMat(DialValue[DialRX]-LastRX, 
-         DialValue[DialRY]-LastRY, 
-         DialValue[DialRZ]-LastRZ,
-         NRotX, NRotY, NRotZ);
- 
-       RV2RMat(LastRX, LastRY, LastRZ,
-         RMat[0], RMat[1], RMat[2]);
-   */
-   
        RV2RMat(DialValue[DialRX]-LastRX,
          DialValue[DialRY]-LastRY,
          DialValue[DialRZ]-LastRZ,
--- 3064,3078 ----
       
      } 
  
!     LOffset[0] = WRange + (int)rint(Zoom*DialValue[DialTX]*XRange);
!     LOffset[1] = HRange + (int)rint(Zoom*DialValue[DialTY]*YRange);
!     LOffset[2] = 10000 + (int)rint(Zoom*DialValue[DialTZ]*ZRange);
          
  
      if ( ( DialValue[DialRX] != LastRX ) || 
           ( DialValue[DialRY] != LastRY ) ||
           ( DialValue[DialRZ] != LastRZ ) ) {
           
        RV2RMat(DialValue[DialRX]-LastRX,
          DialValue[DialRY]-LastRY,
          DialValue[DialRZ]-LastRZ,
***************
*** 2989,2994 ****
--- 3152,3159 ----
          } else Zoom = (DialValue[DialZoom]*MaxZoom) + 1.0;
  
          Scale = Zoom*DScale*Range;
+         LScale = (Long)(Scale*256);
+         iProbeRad = (int)(Scale*ProbeRadius);
          ImageSize = (int)(Scale*WorldSize);
          if( ImageSize < 2 )
          {   ImageRadius = 1;
***************
*** 3044,3051 ****
              {   x = ptr->xorg + ptr->fxorg - CenX; 
                  y = ptr->yorg + ptr->fyorg - CenY; 
                  z = ptr->zorg + ptr->fzorg - CenZ;
!                 ptr->y = (int)(x*MatY[0]+y*MatY[1]+z*MatY[2])+YOffset;
!                 ptr->z = (int)(x*MatZ[0]+y*MatZ[1]+z*MatZ[2])+ZOffset;
              }
              break;
  
--- 3209,3216 ----
              {   x = ptr->xorg + ptr->fxorg - CenX; 
                  y = ptr->yorg + ptr->fyorg - CenY; 
                  z = ptr->zorg + ptr->fzorg - CenZ;
!                 ptr->y = (int)rint(x*MatY[0]+y*MatY[1]+z*MatY[2])+YOffset;
!                 ptr->z = (int)rint(x*MatZ[0]+y*MatZ[1]+z*MatZ[2])+ZOffset;
              }
              break;
  
***************
*** 3054,3061 ****
              {   x = ptr->xorg + ptr->fxorg - CenX; 
                  y = ptr->yorg + ptr->fyorg - CenY; 
                  z = ptr->zorg + ptr->fzorg - CenZ;
!                 ptr->x = (int)(x*MatX[0]+y*MatX[1]+z*MatX[2])+XOffset;
!                 ptr->z = (int)(x*MatZ[0]+y*MatZ[1]+z*MatZ[2])+ZOffset;
              }
              break;
  
--- 3219,3226 ----
              {   x = ptr->xorg + ptr->fxorg - CenX; 
                  y = ptr->yorg + ptr->fyorg - CenY; 
                  z = ptr->zorg + ptr->fzorg - CenZ;
!                 ptr->x = (int)rint(x*MatX[0]+y*MatX[1]+z*MatX[2])+XOffset;
!                 ptr->z = (int)rint(x*MatZ[0]+y*MatZ[1]+z*MatZ[2])+ZOffset;
              }
              break;
  
***************
*** 3064,3088 ****
              {   x = ptr->xorg + ptr->fxorg - CenX; 
                  y = ptr->yorg + ptr->fyorg - CenY; 
                  z = ptr->zorg + ptr->fzorg - CenZ;
!                 ptr->x = (int)(x*MatX[0]+y*MatX[1]+z*MatX[2])+XOffset;
!                 ptr->y = (int)(x*MatY[0]+y*MatY[1]+z*MatY[2])+YOffset;
              }
              break;
  
          default:
              /* This condition scales atomic radii! */
!             if( (DrawAtoms || DrawStars) && (ReDrawFlag&(RFMagnify | RFZoom)) )
              {   ForEachAtom 
                  {   x = ptr->xorg + ptr->fxorg - CenX; 
                      y = ptr->yorg + ptr->fyorg - CenY; 
                      z = ptr->zorg + ptr->fzorg - CenZ;
!                     ptr->x = (int)(x*MatX[0]+y*MatX[1]+z*MatX[2])+XOffset;
!                     ptr->y = (int)(x*MatY[0]+y*MatY[1]+z*MatY[2])+YOffset;
!                     ptr->z = (int)(x*MatZ[0]+y*MatZ[1]+z*MatZ[2])+ZOffset;
!                     if( ptr->flag&SphereFlag )
                      {   ptr->irad = (int)(Scale*(Real)(ptr->radius));
                          if( ptr->irad>MaxAtomRadius )
                              MaxAtomRadius = ptr->irad;
                      }
                  }
              } else
--- 3229,3259 ----
              {   x = ptr->xorg + ptr->fxorg - CenX; 
                  y = ptr->yorg + ptr->fyorg - CenY; 
                  z = ptr->zorg + ptr->fzorg - CenZ;
!                 ptr->x = (int)rint(x*MatX[0]+y*MatX[1]+z*MatX[2])+XOffset;
!                 ptr->y = (int)rint(x*MatY[0]+y*MatY[1]+z*MatY[2])+YOffset;
              }
              break;
  
          default:
              /* This condition scales atomic radii! */
!             if( (DrawAtoms || DrawStars || DrawSurf) &&
!                 (ReDrawFlag&(RFMagnify | RFZoom)) )
              {   ForEachAtom 
                  {   x = ptr->xorg + ptr->fxorg - CenX; 
                      y = ptr->yorg + ptr->fyorg - CenY; 
                      z = ptr->zorg + ptr->fzorg - CenZ;
!                     ptr->x = (int)rint(x*MatX[0]+y*MatX[1]+z*MatX[2])+XOffset;
!                     ptr->y = (int)rint(x*MatY[0]+y*MatY[1]+z*MatY[2])+YOffset;
!                     ptr->z = (int)rint(x*MatZ[0]+y*MatZ[1]+z*MatZ[2])+ZOffset;
!                     if( ptr->flag&(SphereFlag|StarFlag|TouchFlag|ExpandFlag) )
                      {   ptr->irad = (int)(Scale*(Real)(ptr->radius));
                          if( ptr->irad>MaxAtomRadius )
                              MaxAtomRadius = ptr->irad;
+                         if (ptr->flag&ExpandFlag)
+                         {
+                            if ((ptr->irad)+iProbeRad > MaxAtomRadius )
+                              MaxAtomRadius = (ptr->irad)+iProbeRad;
+                         }
                      }
                  }
              } else
***************
*** 3090,3126 ****
                  {   x = ptr->xorg + ptr->fxorg - CenX; 
                      y = ptr->yorg + ptr->fyorg - CenY; 
                      z = ptr->zorg + ptr->fzorg - CenZ;
!                     ptr->x = (int)(x*MatX[0]+y*MatX[1]+z*MatX[2])+XOffset;
!                     ptr->y = (int)(x*MatY[0]+y*MatY[1]+z*MatY[2])+YOffset;
!                     ptr->z = (int)(x*MatZ[0]+y*MatZ[1]+z*MatZ[2])+ZOffset;
                  }
  
              if( ReDrawFlag & ( RFMagnify | RFZoom ) )
              {   if( DrawBonds )
                      ForEachBond
                          if( bptr->flag&CylinderFlag )
!                         {   bptr->irad = (int)(Scale*(Real)(bptr->radius));
!                             bptr->iarad = (int)(Scale*(Real)(bptr->aradius));
                              if( bptr->irad>MaxBondRadius )
                              MaxBondRadius = bptr->irad;
                          }
  
                  for( hptr=Database->hlist; hptr; hptr=hptr->hnext )
  		    if( hptr->flag&CylinderFlag ) {
!                         hptr->irad = (int)(Scale*(Real)(hptr->radius));
!                         hptr->iarad = (int)(Scale*(Real)(hptr->aradius));
                      }
  
                  for( hptr=Database->slist; hptr; hptr=hptr->hnext )
  		    if( hptr->flag&CylinderFlag ) {
!                         hptr->irad = (int)(Scale*(Real)(hptr->radius));
!                         hptr->iarad = (int)(Scale*(Real)(hptr->aradius));
  		    }
  
                  ForEachBack
  		    if( bptr->flag&CylinderFlag ) {
!                         bptr->irad = (int)(Scale*(Real)(bptr->radius));
!                         bptr->iarad = (int)(Scale*(Real)(bptr->aradius));
                      }
              }
      }
--- 3261,3297 ----
                  {   x = ptr->xorg + ptr->fxorg - CenX; 
                      y = ptr->yorg + ptr->fyorg - CenY; 
                      z = ptr->zorg + ptr->fzorg - CenZ;
!                     ptr->x = (int)rint(x*MatX[0]+y*MatX[1]+z*MatX[2])+XOffset;
!                     ptr->y = (int)rint(x*MatY[0]+y*MatY[1]+z*MatY[2])+YOffset;
!                     ptr->z = (int)rint(x*MatZ[0]+y*MatZ[1]+z*MatZ[2])+ZOffset;
                  }
  
              if( ReDrawFlag & ( RFMagnify | RFZoom ) )
              {   if( DrawBonds )
                      ForEachBond
                          if( bptr->flag&CylinderFlag )
!                         {   bptr->irad = (int)rint(Scale*(Real)(bptr->radius));
!                             bptr->iarad = (int)rint(Scale*(Real)(bptr->aradius));
                              if( bptr->irad>MaxBondRadius )
                              MaxBondRadius = bptr->irad;
                          }
  
                  for( hptr=Database->hlist; hptr; hptr=hptr->hnext )
  		    if( hptr->flag&CylinderFlag ) {
!                         hptr->irad = (int)rint(Scale*(Real)(hptr->radius));
!                         hptr->iarad = (int)rint(Scale*(Real)(hptr->aradius));
                      }
  
                  for( hptr=Database->slist; hptr; hptr=hptr->hnext )
  		    if( hptr->flag&CylinderFlag ) {
!                         hptr->irad = (int)rint(Scale*(Real)(hptr->radius));
!                         hptr->iarad = (int)rint(Scale*(Real)(hptr->aradius));
  		    }
  
                  ForEachBack
  		    if( bptr->flag&CylinderFlag ) {
!                         bptr->irad = (int)rint(Scale*(Real)(bptr->radius));
!                         bptr->iarad = (int)rint(Scale*(Real)(bptr->aradius));
                      }
              }
      }
*** transfor.h	2004/05/07 19:46:16	1.1
--- transfor.h	2005/01/16 20:25:16
***************
*** 210,215 ****
--- 213,219 ----
  int UseDotColPot;
  
  Real Scale,MaxZoom;
+ Long LScale;
  Real DScale,IScale;
  Long SideLen,Offset;
  Card WorldRadius,WorldSize,LocalRadius;
***************
*** 221,226 ****
--- 225,231 ----
  int DrawAtoms,MaxAtomRadius;
  int DrawBonds,MaxBondRadius;
  int DrawStars;
+ int DrawSurf;
  int DrawRibbon;
  int ZoneBoth;
  int ModelInclude;
***************
*** 259,264 ****
--- 264,270 ----
  extern int UseDotColPot;
  
  extern Real Scale,MaxZoom;
+ extern Long LScale;
  extern Real DScale,IScale;
  extern Long SideLen,Offset;
  extern Card WorldRadius,WorldSize,LocalRadius;
***************
*** 270,275 ****
--- 276,282 ----
  extern int DrawAtoms,MaxAtomRadius;
  extern int DrawBonds,MaxBondRadius;
  extern int DrawStars;
+ extern int DrawSurf;
  extern int DrawRibbon;
  extern int ZoneBoth;
  extern int ModelInclude;
*** x11win.c	2004/05/07 19:46:16	1.1
--- x11win.c	2005/01/16 20:25:17
***************
*** 186,192 ****
      { &(MolNStr[4]),                            0x01,  0, 
          &MolNLen[4],            &MoleculeIndex, 4 } };
  
! static MenuItem DisMenu[8] = {
      { &MsgStrs[StrMWirefr] /* "Wireframe"    */,     0x11,  &MsgAuxl[StrMWirefr],
          &MsgLens[StrMWirefr],    NULL, 0     },
      { &MsgStrs[StrMBackbn] /* "Backbone"     */,     0x11,  &MsgAuxl[StrMBackbn],
--- 189,195 ----
      { &(MolNStr[4]),                            0x01,  0, 
          &MolNLen[4],            &MoleculeIndex, 4 } };
  
! static MenuItem DisMenu[9] = {
      { &MsgStrs[StrMWirefr] /* "Wireframe"    */,     0x11,  &MsgAuxl[StrMWirefr],
          &MsgLens[StrMWirefr],    NULL, 0     },
      { &MsgStrs[StrMBackbn] /* "Backbone"     */,     0x11,  &MsgAuxl[StrMBackbn],
***************
*** 202,208 ****
      { &MsgStrs[StrMStrands]/* "Strands"      */,     0x11,  &MsgAuxl[StrMStrands],
          &MsgLens[StrMStrands],   NULL, 0     },
      { &MsgStrs[StrMCartoon]/* "Cartoons"     */,     0x11,  &MsgAuxl[StrMCartoon],
!         &MsgLens[StrMCartoon],   NULL, 0     }};
  
  
  static MenuItem ColMenu[10] = {
--- 205,214 ----
      { &MsgStrs[StrMStrands]/* "Strands"      */,     0x11,  &MsgAuxl[StrMStrands],
          &MsgLens[StrMStrands],   NULL, 0     },
      { &MsgStrs[StrMCartoon]/* "Cartoons"     */,     0x11,  &MsgAuxl[StrMCartoon],
!         &MsgLens[StrMCartoon],   NULL, 0     },
!     { &MsgStrs[StrMMolSurf]/* "Molecular Surface"    */,     0x11,  &MsgAuxl[StrMMolSurf],
!         &MsgLens[StrMMolSurf],   NULL, 0     }};
!  
  
  
  static MenuItem ColMenu[10] = {
***************
*** 308,314 ****
  static BarItem MenuBar[MenuBarMax] = { 
      { FilMenu,  &MsgStrs[StrMFile]    /* "File"     */,  5, 0x01,&MsgAuxl[StrMFile],
          &MsgLens[StrMFile], &NumMolecules},
!     { DisMenu,  &MsgStrs[StrMDisplay] /* "Display"  */,  8, 0x01,&MsgAuxl[StrMDisplay],
          &MsgLens[StrMDisplay], NULL },
      { ColMenu,  &MsgStrs[StrMColour]  /* "Colours"  */, 10, 0x01,&MsgAuxl[StrMColour],
          &MsgLens[StrMColour], NULL },
--- 314,320 ----
  static BarItem MenuBar[MenuBarMax] = { 
      { FilMenu,  &MsgStrs[StrMFile]    /* "File"     */,  5, 0x01,&MsgAuxl[StrMFile],
          &MsgLens[StrMFile], &NumMolecules},
!     { DisMenu,  &MsgStrs[StrMDisplay] /* "Display"  */,  9, 0x01,&MsgAuxl[StrMDisplay],
          &MsgLens[StrMDisplay], NULL },
      { ColMenu,  &MsgStrs[StrMColour]  /* "Colours"  */, 10, 0x01,&MsgAuxl[StrMColour],
          &MsgLens[StrMColour], NULL },
